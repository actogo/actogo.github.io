[{"title":"计算机网络_第2章","date":"2021-06-16T12:38:15.000Z","path":"2021/06/16/计算机网络02/","text":"第二章摘要：物理层。 物理层的基本概念物理层的基本概念： 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。 物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。 传输媒体： 导引型传输媒体 双绞线 同轴电缆 光纤 电力线 非导引型传输媒体 微波 无线电波 红外线 可见光 物理层协议的主要任务： 传输方式串行传输与并行传输 同步传输与异步传输 单向通信、双向交替通信、双向同时通信 编码与调制 码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。 常用编码不归零编码 不归零编码存在问题： 需要额外一根传输线来传输时钟信号，使发送方和接收方同步。 对于计算机网络，宁愿利用这根传输线传输数据信号，而不是传输时钟信号！ 归零编码 每个码元传输结束后信号都要“归零”所以接收方只要在信号归零后进行采样即可，不需要单独的时钟信号。 实际上，归零编码相当于把时钟信号用“归零”方式编码在了数据之内，这称为“自同步”信号。 但是，归零编码中大部分的数据带宽，都用来传输“归零”而浪费掉了。 曼切斯特编码 码元中间时刻的跳变既表示时钟，又表示数据。 差分曼切斯特编码 跳变仅表示时钟； 码元开始处电平是否发生变化表示数据。 混合调制 因为频率和相位是相关的，即频率是相位随时间的变化率。所以一次只能调制频率和相位两个中的一个。 通常情况下，相位和振幅可以结合起来一起调制，称为正交振幅调制QAM。 正交振幅调制QAM QAM-16 12种相位； 每种相位有1或2种振幅可选； 可以调制出16种码元（波形），每种码元可以对应表示4个比特； 码元与4个比特的对应关系采用格雷码，任意两个相邻码元只有1个比特不同。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络_第1章","date":"2021-06-13T08:27:16.000Z","path":"2021/06/13/计算机网络01/","text":"第1章摘要：计算机概述。 三种交换方式1、电路交换电路交换(Circuit Switching)： 电话交换机接通电话线的方式称为电路交换; 从通信资源的分配角度来看,交换(Switching)就是按照某种方式动态地分配传输线路的资源; 电路交换的三个步骤: 建立连接(分配通信资源) 通话(一直占用通信资源) 释放连接(归还通信资源) 当使用电路交换来传送计算机数据时,其线路的传输效率往往很低。 2、分组交换分组交换（Packet Switching） 分组交换采取存储转发技术； 报文添加头部构成分组（或者报文添加包头构成包）； 发送方负责构造分组，发送分组； 路由器负责缓存分组，转发分组； 接收方负责接收分组，还原报文。 3、报文交换报文交换（Message Switching） 报文交换采用存储转发原理，等到整个报文传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。 4、三种交换方式进行对比 优点 缺点 电路交换 通信时延小；有序传输；没有冲突；适用范国广；实时性强；控制简单。 建立连接时间长；线路独占,使用效率低；灵活性差；难以规范化。 报文交换 无需建立连接；动态分配线路；提高线路可靠性；提高线路利用率；提供多目标服务。 引起了转发时延；需要较大存储缓存空间；需要传输额外的信息量(包头)。 分组交换 无需建立连接；线路利用率高；简化了存储管理；加速传输；减少出错概率和重发数据量。 引起了转发时延；需要传输额外的信息量；对于数据报服务,存在失序,丢失或重复分组的问题;对于虚电路服务,存在呼叫建立数据传输和虚电路释放三个过程。 计算机网络的定义与分类计算机网络的定义：一些互连的、自治的计算机的集合。 互连的：是指计算机之间可以通过有线或无线的方式进行数据通信; 自治的：是指独立的计算机,它有自己的硬件和软件,可以单独运行使用; 集合：是指至少需要两台计算机。 计算机网络的分类（了解）： 计算机网络的性能指标比特：计算机中数据量的单位,也是信息论中信息量的单位。一个比特就是二进制数字中的一个1或0。 常用的数据量单位： 8 bit = 1 Byte KB = 2^10 B MB = 2^20 B GB = 2^30 B TB = 2^40 B 速率连接在计算机网络上的主机在数字信道上传送比特的速率，也称为比特率或数据率。 常用数据速率单位： bit/s (bps) kb/s = 10^3 b/s (bps) Mb/s = 10^6 b/s (bps) Gb/s = 10^9 b/s (bps) Tb/s = 10^12 b/s (bps) 带宽带宽在模拟信号系统中的意义：信号所包含的各种不同频率成分所占据的频率范围。单位：Hz （kHz，MHz，GHz） 带宽在计算机网络中的意义：用来表示网络的通信线路所能传送数据的能力，因此网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的”最高数据率” 。单位： b/s （kb/s， Mb/s， Gb/s， Tb/s） 吞吐量吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或额定速率的限制。 时延 时延带宽积时延带宽积 = 传播时延 * 带宽 若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特； 链路的时延带宽积又称为以比特为单位的链路长度。 往返时间 在许多情况下，因特网上的信息不仅仅单方向传输，而是双向交互； 我们有时很需要知道双向交互一次所需的时间； 因此，往返时间RTT（Round-Trip Time） 也是一个重要的性能指标。 利用率信道利用率：用来表示某信道有百分之几的时间是被利用的（有数据通过）； 网络利用率：全网络的信道利用率的加权平均。 注意点： 根据排队论，当某信道的利用率增大时，该信道引起的时延也会迅速增加； 因此，信道利用率并非越高越好； 如果令D0表示网络空闲时的时延， D表示网络当前的时延，那么在适当的假定条件下，可以用下面的简单公式来表示D， D0和利用率U之间的关系：D=D0/(1-U)； 当网络的利用率达到50%时，时延就要加倍； 当网络的利用率超过50%时，时延急剧增大； 当网络的利用率接近100%时，时延就趋于无穷大； 因此，一些拥有较大主于网的ISP通常会控制它们的信道利用率不超过50%。如果超过了，就要准备扩容，增大线路的带宽。 也不能使信道利用率太低，这会使宝贵的通信资源被白白浪费。应该使用一些机制，可以根据情况动态调整输入到网络中的通信量，使网络利用率保持在一个合理的范围内。 丢包率 丢包率即分组丢失率，是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率。 丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等。 丢包率是网络运维人员非常关心的一个网络性能指标，但对于普通用户来说往往并不关心这个指标，因为他们通常意识不到网络丢包。 分组丢失主要有两种情况： 分组在传输过程中出现误码，被结点丢弃； 分组到达一 台队列已满的分组交换机时被丢弃；在通信量较大时就可能造成网络拥塞。 因此，丢包率反映了网络的拥塞情况： 无拥塞时路径丢包率为0； 轻度拥塞时路径丢包率为1%~4%； 严重拥塞时路径丢包率为5%~15%。 计算机网络体系结构常见的计算机网络体系结构 OSI失败的原因可归纳为： OSI的专家们缺乏实际经验，他们在完成OSI标准时缺乏商业驱动力； OSI的协议实现起来过分复杂，而且运行效率很低； OSI标准的制定周期太长，因而使得按OSI标准生产的设备无法及时进入市场； OSI的层次划分不太合理，有些功能在多个层次中重复出现。 计算机网络体系结构分层的必要性 计算机网络体系结构分层思想举例主机和Web服务器之间基于网络的通信实质上是主机上面应用程序的应用进程与Web服务器应用进程之间基于网络的通信。 计算机网络体系结构专用术语 实体：任何可发送或接收信息的硬件或软件进程。对等实体：收发双方相同层次中的实体。 协议：控制两个对等实体进行逻辑通信的规则的集合。 服务： 在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务。 要实现本层协议，还需要使用下面一层所提供的服务。 协议是“水平的” ，服务是”垂直的”。 实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是”透明”的。 服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型。 数据链路层的服务访问点为帧的“类型”字段； 网络层的服务访问点为IP数据报首部中的“协议字段”’； 运输层的服务访问点为“端口号”。 服务原语：上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语。 协议数据单元PDU ：对等层次之间传送的数据包称为该层的协议数据单元。 服务数据单元SDU ：同一系统内，层与层之间交换的数据包称为服务数据单元。 多个SDU可以合成为一个PDU； 一个SDU也可划分为几个PDU。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Hello World","date":"2021-05-17T04:32:31.843Z","path":"2021/05/17/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Hello","slug":"Hello","permalink":"http://example.com/tags/Hello/"}]},{"title":"STL源码剖析","date":"2021-04-15T10:45:56.000Z","path":"2021/04/15/STL源码剖析/","text":"源码面前，了无秘密。 STL 六大组件 容器(containers)：string,vector,list,deque,map 算法(algorithms)：sort,search,copy,erase 迭代器(iterators)：重载*operator,operator-&gt;,operator++,operator–**（native pointer is also a iterator） 仿函数(functors)：重载operator() 配接器(adapters)：queue,stack 配置器(allocators)：memory manager 空间配置器迭代器序列式容器array,vector,heap,priority-queue,list,slist,deque,stack,queue vectorarray是静态空间，vector是动态空间。","categories":[{"name":"STL","slug":"STL","permalink":"http://example.com/categories/STL/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"}]},{"title":"C++09_常用算法","date":"2020-10-06T00:34:35.000Z","path":"2020/10/06/C-09-常用算法/","text":"常用的遍历算法 for_each语法：for_each(v.begin(),v.end(),func()); func()可以为普通函数，也可以为仿函数 123456789101112131415161718192021222324252627void print01(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;class print02&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; //遍历算法for_each; //普通函数 for_each(v.begin(), v.end(), print01); cout &lt;&lt; endl; //仿函数 for_each(v.begin(), v.end(), print02()); cout &lt;&lt; endl;&#125; transform语法：transform(v.begin(),v.end(),func()); 搬运容器到另一个容器 1234567891011121314151617181920212223242526int transform01(int val)&#123; return val+1;&#125;class print&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; vector&lt;int&gt;v1; v1.resize(v.size()); transform(v.begin(), v.end(), v1.begin(), transform01); for_each(v1.begin(), v1.end(),print()); cout &lt;&lt; endl;&#125; 常用的查找算法find语法：find(v.begin(),v.end(),value); 按照值来查找元素，找到元素就返回元素迭代器，否则返回最后元素的迭代器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 8); if (it == v.end()) &#123; cout &lt;&lt; &quot;没有找到该元素！&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到该元素：&quot; &lt;&lt; *it &lt;&lt; endl; &#125;&#125;class Person&#123;public: Person(string name,int age) &#123; this-&gt; m_Name = name; this-&gt;m_Age = age; &#125; bool operator ==(const Person&amp;p) &#123; if (this-&gt;m_Name == p.m_Name&amp;&amp;this-&gt;m_Age == p.m_Age) &#123; return true; &#125; else return false; &#125;public: string m_Name; int m_Age; &#125;;void test02()&#123; vector&lt;Person&gt;v; Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector&lt;Person&gt;::iterator it = find(v.begin(),v.end(),p2); if (it == v.end()) &#123; cout &lt;&lt; &quot;没有找到该元素！&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到该元素,姓名：&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot;\\t年龄：&quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl; &#125;&#125; find_if语法：find_if(v.begin(),v.end(),Pred); Pred是谓词，就是仿函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class greater5&#123;public: bool operator()(int val) &#123; return val &gt; 5; &#125;&#125;;void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; vector&lt;int&gt;::iterator it1 = find_if(it, v.end(), greater5()); if (it1 != v.end()) &#123; cout &lt;&lt; *it1 &lt;&lt; endl; it = it1; &#125; else &#123; cout &lt;&lt; &quot;没有找到该元素！&quot; &lt;&lt; endl; &#125; &#125;&#125;class person&#123;public: person(string name,int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;class greater20&#123;public: bool operator()(const person&amp;p) &#123; return p.m_Age &gt; 20; &#125;&#125;;void test02()&#123; vector&lt;person&gt;v; person p1(&quot;aaa&quot;, 10); person p2(&quot;bbb&quot;, 20); person p3(&quot;ccc&quot;, 30); person p4(&quot;ddd&quot;, 40); person p5(&quot;eee&quot;, 50); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); for (vector&lt;person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; vector&lt;person&gt;::iterator it1 = find_if(it, v.end(), greater20()); if (it1 != v.end()) &#123; cout &lt;&lt; &quot;姓名：&quot;&lt;&lt;it-&gt;m_Name&lt;&lt;&quot;\\t年龄：&quot;&lt;&lt;it-&gt;m_Age &lt;&lt; endl; it = it1; &#125; else &#123; cout &lt;&lt; &quot;没有找到该元素！&quot; &lt;&lt; endl; &#125; &#125;&#125; adjacent_find语法：adjacent_find(v,begin();v.end()); 查找相邻字符元素，返回相邻元素的第一个位置的迭代器。 123456789101112131415161718192021222324void test01()&#123; vector&lt;int&gt;v; v.push_back(0); v.push_back(8); v.push_back(7); v.push_back(3); v.push_back(3); v.push_back(1); v.push_back(2); v.push_back(0); vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end()); if (it == v.end()) &#123; cout &lt;&lt; &quot;没有找到重复元素！&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到重复元素:&quot; &lt;&lt; *it &lt;&lt; endl; &#125;&#125; binary_search语法：binary_search(v.begin(),v.end(),value); 查找指定元素，只适用于有序序列，查到返回true，否则false。 123456789101112131415161718void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; //查找的算法只适用于有序序列,返回布尔值 bool ret=binary_search(v.begin(), v.end(), 9); if (ret) &#123; cout &lt;&lt; &quot;找到元素&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl; &#125;&#125; count语法：count(v.begin(),v.end(),value); 统计元素个数，value为要统计的元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void test01()&#123; vector&lt;int&gt;v; //插入内置数据 v.push_back(10); v.push_back(40); v.push_back(20); v.push_back(40); v.push_back(40); //统计元素个数 int num = count(v.begin(), v.end(), 40); cout &lt;&lt; &quot;容器中40的个数为：&quot; &lt;&lt; num &lt;&lt; endl;&#125;class person&#123;public: person(string name, int age) &#123; m_name = name; m_age = age; &#125; bool operator ==(const person &amp;p) &#123; if (p.m_age == this-&gt;m_age) return true; else return false; &#125;public: string m_name; int m_age;&#125;;void test02()&#123; vector&lt;person&gt;v1; person p1(&quot;库里&quot;, 30); person p2(&quot;乔丹&quot;, 23); person p3(&quot;詹姆斯&quot;, 23); person p4(&quot;杜兰特&quot;, 35); person p5(&quot;戴维斯&quot;, 23); person p6(&quot;巴特勒&quot;, 23); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); v1.push_back(p6); int num = count(v1.begin(), v1.end(), p2); cout &lt;&lt; &quot;和&quot; &lt;&lt; p2.m_name &lt;&lt; &quot;同号码的运动员有&quot; &lt;&lt; num-1 &lt;&lt; &quot;个。&quot; &lt;&lt; endl;&#125; count_if语法：count_if(v.begin(),v.end(),pred); 按照条件统计元素个数，pred为谓词。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Greater20&#123;public: bool operator()(int val) &#123; return val &gt; 20; &#125;&#125;;void test01()&#123; vector&lt;int&gt;v; //插入内置数据 v.push_back(10); v.push_back(40); v.push_back(20); v.push_back(40); v.push_back(40); //统计元素个数 int num = count_if(v.begin(), v.end(), Greater20()); cout &lt;&lt; &quot;容器中大于20的个数为：&quot; &lt;&lt; num &lt;&lt; endl;&#125;class person&#123;public: person(string name, int age) &#123; m_name = name; m_age = age; &#125;public: string m_name; int m_age;&#125;;class Greater23&#123;public: bool operator ()(const person &amp;p) &#123; return p.m_age &gt; 23; &#125;&#125;;void test02()&#123; vector&lt;person&gt;v1; person p1(&quot;库里&quot;, 30); person p2(&quot;乔丹&quot;, 23); person p3(&quot;詹姆斯&quot;, 23); person p4(&quot;杜兰特&quot;, 35); person p5(&quot;戴维斯&quot;, 23); person p6(&quot;巴特勒&quot;, 23); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); v1.push_back(p6); int num = count_if(v1.begin(), v1.end(),Greater23() ); cout &lt;&lt; &quot;号码大于&quot; &lt;&lt; p2.m_age &lt;&lt; &quot;的运动员有&quot; &lt;&lt; num &lt;&lt; &quot;个。&quot; &lt;&lt; endl;&#125; 常用的排序算法sort语法：sort(v.begin(),v.end(),pred); 对容器内部的元素进行排序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667void myprint(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01()&#123; vector&lt;int&gt;v; //插入内置数据 v.push_back(10); v.push_back(40); v.push_back(20); v.push_back(40); v.push_back(40); //默认排序 sort(v.begin(), v.end()); for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl; //降序排序 sort(v.begin(), v.end(), greater&lt;int&gt;()); for_each(v.begin(), v.end(), myprint);&#125;class person&#123;public: person(string name, int age) &#123; m_name = name; m_age = age; &#125;public: string m_name; int m_age;&#125;;class Greater23&#123;public: bool operator ()(const person&amp; p1,const person&amp; p2) &#123; return p1.m_age &gt; p2.m_age; &#125;&#125;;void myprint01(const person &amp;p)&#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.m_name &lt;&lt; &quot;\\t号码：&quot; &lt;&lt; p.m_age &lt;&lt; endl;&#125;void test02()&#123; vector&lt;person&gt;v1; person p1(&quot;库里&quot;, 30); person p2(&quot;乔丹&quot;, 23); person p3(&quot;詹姆斯&quot;, 23); person p4(&quot;杜兰特&quot;, 35); person p5(&quot;戴维斯&quot;, 23); person p6(&quot;巴特勒&quot;, 23); v1.push_back(p1); v1.push_back(p2); v1.push_back(p3); v1.push_back(p4); v1.push_back(p5); v1.push_back(p6); cout &lt;&lt; endl; sort(v1.begin(), v1.end(), Greater23()); for_each(v1.begin(), v1.end(), myprint01);&#125; random_shuffle语法：random_shuffle(v.begin(),v.end()); 打乱容器中元素顺序，加入时间种子。 1234567891011121314151617181920void myprint(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01()&#123; srand((unsigned int)time(NULL)); vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl; random_shuffle(v.begin(), v.end()); for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl;&#125; merge语法：merge(v1.begin(),v1.end(),v2.begin(),v2,end(),v3.begin()); 两个容器元素合并，并存储到另一个容器中，注意两个容器的元素序列必须有序，并且顺序一致。 12345678910111213141516171819202122void myprint(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01()&#123; vector&lt;int&gt;v1; vector&lt;int&gt;v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(i+1); &#125; vector&lt;int&gt;v3; v3.resize(v1.size() + v2.size()); merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin()); for_each(v3.begin(), v3.end(), myprint); cout &lt;&lt; endl;&#125; reverse语法：reverse(v.begin(),v.end()); 使容器内部元素进行反转。 12345678910111213141516171819202122void myprint(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01()&#123; vector&lt;int&gt;v; v.push_back(10); v.push_back(50); v.push_back(40); v.push_back(20); v.push_back(30); cout&lt;&lt;&quot;反转前:&quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myprint); reverse(v.begin(), v.end()); cout &lt;&lt; endl; cout &lt;&lt; &quot;反转后:&quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl;&#125; 常用的拷贝和替换算法copy语法;copy(v.begin(),v.end(),v1.begin()); 将容器v的元素复制到容器v1中。 1234567891011121314151617181920void myprint(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl; vector&lt;int&gt;v1; v1.resize(v.size()); copy(v.begin(), v.end(), v1.begin()); for_each(v1.begin(), v1.end(), myprint); cout &lt;&lt; endl;&#125; replace语法：replace(v.begin(),v.end(),old_value,new_vlaue); 将容器内指定范围的旧元素替换为新元素。 12345678910111213141516171819202122232425262728class myprint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt;v; v.push_back(20); v.push_back(10); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(20); cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myprint()); cout &lt;&lt; endl; cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl; replace(v.begin(), v.end(), 20,2000); for_each(v.begin(), v.end(), myprint()); cout &lt;&lt; endl;&#125; replace_if语法：replace_if(v.begin(),v.end(),pred,newvalue); 按照条件替换元素，pred为谓词。 12345678910111213141516171819202122232425262728293031323334void myprint(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;class greater20&#123;public: bool operator()(int val) &#123; return val &gt; 20; &#125;&#125;;void test01()&#123; vector&lt;int&gt;v; v.push_back(10); v.push_back(30); v.push_back(20); v.push_back(50); v.push_back(40); v.push_back(30); v.push_back(20); cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl; cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl; replace_if(v.begin(), v.end(), greater20(), 3000); for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl;&#125; swap语法：swap(v1,v2); 互换两个容器的元素，两个容器必须同类型。 1234567891011121314151617181920212223242526void myprint(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01()&#123; vector&lt;int&gt;v1,v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(10 - i); &#125; cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl; for_each(v1.begin(), v1.end(), myprint); cout &lt;&lt; endl; for_each(v2.begin(), v2.end(), myprint); cout &lt;&lt; endl; swap(v1, v2); cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl; for_each(v1.begin(), v1.end(), myprint); cout &lt;&lt; endl; for_each(v2.begin(), v2.end(), myprint); cout &lt;&lt; endl;&#125; 常用的算术生成算法小型算法，使用时应包含头文件为 #include accumulate语法：accumlate(v.begin(),v.end(),value); 计算区间内容器元素累计总和，value为起始值 1234567891011void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt;= 100; i++) &#123; v.push_back(i); &#125; int total= accumulate(v.begin(), v.end(),0); cout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl;&#125; fill语法：fill(v.begin(),v.end(),value); 向容器中填充指定元素，value为填充值。 12345678910111213void myprint(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01()&#123; vector&lt;int&gt;v; v.resize(10); fill(v.begin(), v.end(), 1000); for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl;&#125; 常用集合算法set_intersection语法：set_intersection(v1.begin(),v1.end(),v2.begin(),v2.end(),v3.begin()) 求两个容器的交集，两个容器必须是系统的有序序列。 123456789101112131415161718192021222324void myprint(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01()&#123; vector&lt;int&gt;v1; vector&lt;int&gt;v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(i+5); &#125; vector&lt;int&gt;v3; v3.resize(min(v1.size(), v2.size())); vector&lt;int&gt;::iterator itEnd=set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin()); for_each(v1.begin(), v1.end(), myprint); cout &lt;&lt; endl; for_each(v2.begin(), v2.end(), myprint); cout &lt;&lt; endl; for_each(v3.begin(), itEnd, myprint); cout &lt;&lt; endl;&#125; set_union语法：set_union(v1.begin(),v1.end(),v2.begin(),v2.end(),v3.begin()); 求两个集合的并集，两个集合必须是有序序列。 123456789101112131415161718192021222324void myprint(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01()&#123; vector&lt;int&gt;v1; vector&lt;int&gt;v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back((i-1)*2); &#125; vector&lt;int&gt;v3; v3.resize(v1.size()+v2.size()); vector&lt;int&gt;::iterator itEnd=set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin()); for_each(v1.begin(), v1.end(), myprint); cout &lt;&lt; endl; for_each(v2.begin(), v2.end(), myprint); cout &lt;&lt; endl; for_each(v3.begin(), itEnd, myprint); cout &lt;&lt; endl;&#125; set_difference语法：set_difference(v1.begin(),v1.end(),v2.begin(),v2.end(),v3.begin()); 求两个集合的交集，两个集合必须是系统的有序序列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;numeric&gt;void myprint(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01()&#123; vector&lt;int&gt;v1; vector&lt;int&gt;v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(i+5); &#125; vector&lt;int&gt;v3,v4; v3.resize(max(v1.size(), v2.size())); v4.resize(max(v1.size(), v2.size())); vector&lt;int&gt;::iterator itEnd=set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin()); vector&lt;int&gt;::iterator itEnd2 = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), v4.begin()); cout &lt;&lt; &quot;v1的元素有：&quot; &lt;&lt; endl; for_each(v1.begin(), v1.end(), myprint); cout &lt;&lt; endl; cout &lt;&lt; &quot;v2的元素有：&quot; &lt;&lt; endl; for_each(v2.begin(), v2.end(), myprint); cout &lt;&lt; endl; cout &lt;&lt; &quot;v2和v1的差集为：&quot; &lt;&lt; endl; for_each(v3.begin(), itEnd, myprint); cout &lt;&lt; endl; cout &lt;&lt; &quot;v1和v2的差集为：&quot; &lt;&lt; endl; for_each(v4.begin(), itEnd2, myprint); cout &lt;&lt; endl;&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++08_函数对象","date":"2020-10-03T07:42:47.000Z","path":"2020/10/03/C-08-函数对象/","text":"函数对象 函数对象（仿函数）本质就是一个重载了函数调用操作符的类，不是一个函数。 函数对象使用特点： 1.函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值 2.函数对象可以作为参数传递 3.函数对象可以自定义状态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class myadd&#123;public: int operator ()(int v1,int v2) &#123; return (v1 + v2); &#125;&#125;;void test01()&#123; myadd Myadd; cout &lt;&lt; Myadd(10, 20) &lt;&lt; endl;&#125;class myprint&#123;public: myprint() &#123; this-&gt;counter = 0; &#125; void operator()(string text) &#123; cout &lt;&lt; text &lt;&lt; endl; counter++; &#125; int counter;&#125;;void test02()&#123; myprint Myprint; Myprint(&quot;Hello C++&quot;); Myprint(&quot;Hello C++&quot;); Myprint(&quot;Hello C++&quot;); Myprint(&quot;Hello C++&quot;); Myprint(&quot;Hello C++&quot;); cout &lt;&lt; &quot;函数调用了&quot; &lt;&lt; Myprint.counter &lt;&lt;&quot;次。&quot;&lt;&lt; endl;&#125;void MP(myprint&amp;mp,string text)&#123; mp(text);&#125;void test03()&#123; myprint Mp; MP(Mp, &quot;STM32!&quot;);&#125; 谓词一元谓词仿函数只有一个函数参数叫做一元谓词 123456789101112131415161718192021222324class more_five&#123;public: //一元谓词 bool operator()(int v1) &#123; return v1 &gt; 5; &#125;&#125;;//一元谓词void test01()&#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; //查找大于5的数,可以用匿名函数对象 vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), more_five()); if (it != v.end()) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125;&#125; 二元谓词仿函数只有两个函数参数叫做二元谓词 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;#include&lt;vector&gt;#include&lt;algorithm&gt;class Mycompare&#123;public: bool operator ()(int v1,int v2) &#123; return v1 &gt; v2; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(20); v.push_back(10); v.push_back(50); v.push_back(40); v.push_back(30); //默认排序：升序 sort(v.begin(), v.end()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl; //构造函数对象实现降序排序 sort(v.begin(), v.end(), Mycompare()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 内建函数对象STL内部构建的一些函数对象，包含头文件#include就可以调用。 算术仿函数六种用法： 1.plusp;p(a,b);//加法仿函数 2.minusmin;min(a,b);//减法仿函数 3.multipliesmul;mul(a,b);//乘法仿函数 4.dividesdiv;div(a,b);//除法仿函数 5.modulusmod;mod(a,b);//取模仿函数 6.negateneg;neg(a,b);//取反仿函数 123456789101112131415161718192021void test01()&#123; //加法仿函数 plus&lt;int&gt;p; cout &lt;&lt; p(10, 20) &lt;&lt; endl; //减法仿函数 minus&lt;int&gt;min; cout&lt;&lt;min(10, 20)&lt;&lt;endl; //乘法仿函数 multiplies&lt;int&gt;mul; cout&lt;&lt;mul(10, 20) &lt;&lt; endl; //除法仿函数 divides&lt;int&gt;d; cout&lt;&lt;d(10, 20) &lt;&lt; endl; //取模仿函数 modulus&lt;int&gt;mod; cout &lt;&lt; mod(20, 3) &lt;&lt; endl; //取反仿函数 negate&lt;int&gt;neg; cout &lt;&lt; neg(50) &lt;&lt; endl;;&#125; 关系仿函数六种用法 equal_to;//等于 not_equal_to;//不等于 greater;//大于 greater_equal;//大于等于 less;//小于 less_equal;//小于等于 123456789101112131415161718void test01()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(20); v.push_back(50); v.push_back(40); //大于仿函数 sort(v.begin(), v.end(),greater&lt;int&gt;()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 逻辑仿函数三种用法： logical_or();//逻辑运算符或 logical_and();//逻辑运算符和 logical_not();//逻辑运算符非 12345678910111213141516171819202122232425void test01()&#123; vector&lt;int&gt;v; v.push_back(true); v.push_back(false); v.push_back(true); v.push_back(false); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; vector&lt;int&gt;v2; v2.resize(v.size()); transform(v.begin(), v.end(), v2.begin(),logical_not&lt;bool&gt;()); cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl; for (vector&lt;int&gt;::iterator it = v2.begin(); it != v2.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++07_常用容器思维导图","date":"2020-09-30T01:02:08.000Z","path":"2020/09/30/C-07-常用容器思维导图/","text":"常用容器整理","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++07_STL常用容器","date":"2020-08-31T00:10:33.000Z","path":"2020/08/31/C-07-常用容器/","text":"string容器 string 的基本概念string是C++风格的字符串，而string本质是一个类。 string和char*的区别：char* 是一个指针，string是一个类，类内部封装了char* ，管理这个字符串，是一个char*型的容器。 特点：string管理char*所分配的内存，不用担心复制越界和取值越界等问题，由类内部进行负责。 string构造函数三种方式： 1.创建空的字符串：string str; 2.使用字符串初始化string对象：string str(“字符串”); 3.使用string对象初始化另一个string对象：string str1(str2); 4.使用n个字符初始化string对象：string str(5,’A’); 1234567891011121314void test01()&#123; string s1;//默认构造函数,创建空字符串 const char* str = &quot;hello world&quot;; string s2(str); cout &lt;&lt; &quot;s2 = &quot; &lt;&lt; s2 &lt;&lt; endl;//使用字符串初始化 string s3(s2);//拷贝构造函数 cout &lt;&lt; &quot;s3 = &quot; &lt;&lt; s3 &lt;&lt; endl;//使用一个string对象初始化另一个string对象 string s4(10, &#x27;a&#x27;); cout &lt;&lt; &quot;s4 = &quot; &lt;&lt; s4 &lt;&lt; endl;//使用n个字符初始化&#125; string赋值函数七种方式： 1.字符串赋值给string对象：string str=(“字符串”); 2.string对象赋值给另一个string对象：string str=str1; 3.字符赋值给string对象：string str=’A’; 4.字符串赋值给string对象：string str.assign(“字符串”); 5.把字符串的前n个字符赋值给string对象：string str.assign(“字符串”,n); 6.把string对象赋值给另一个string对象：string str.assign(str1); 7.把n个字符赋值给当前字符串：string str.assign(5,’A’); 12345678910111213141516171819202122232425262728293031323334353637void test01()&#123; //char*类型字符串 赋值给当前字符串 string str1; str1 = &quot;hello world&quot;; cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; //将字符串s赋值给当前字符串 string str2; str2 = str1; cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; endl; //将字符赋值给当前字符串 string str3; str3 = &#x27;a&#x27;; cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl; //char*类型字符串，赋值给当前字符串 string str4; str4.assign(&quot;hello C++&quot;); cout &lt;&lt; &quot;str4 = &quot; &lt;&lt; str4 &lt;&lt; endl; //将字符串s赋值给当前字符串 string str5; str5.assign(str4); cout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; endl; //将字符串s的前n个字符赋值给当前字符串 string str6; str6.assign(&quot;hello C++&quot;,5); cout &lt;&lt; &quot;str6 = &quot; &lt;&lt; str6 &lt;&lt; endl; //将n个相同的字符赋值给当前字符串 string str7; str7.assign(10, &#x27;s&#x27;); cout &lt;&lt; &quot;str7 = &quot; &lt;&lt; str7 &lt;&lt; endl;&#125; 注意区分：添加前n个字符是(“字符串”,n)，字符串在前，字符个数在后；赋值n个相同的字符是(n,’字符’),字符个数在前，字符在后。 string 字符串拼接七种方式： 1.把字符串拼接在string对象末尾：string str+=”字符串”； 2.把字符拼接在string对象末尾：string str+=‘字符’； 3.把string对象拼接在另一个string对象末尾：string str+=str2； 4.把字符串拼接在string对象末尾：string str.append(“字符串”)； 5.把字符串的前n个字符拼接在string对象末尾：string str.append(“字符串”，n)； 6.把string对象拼接在另一个string对象末尾：string str.append(“str 2”)； 7.把字符串从pos开始的n个字符拼接在string对象末尾：string str.append(“字符串”,pos,n)； 1234567891011121314151617181920212223242526272829303132333435void test01()&#123; //将字符串接到当前字符串末尾 string str1 = &quot;我&quot;; str1 += &quot;爱玩游戏&quot;; cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; //将字符接到当前字符串末尾 str1 += &#x27;:&#x27;; cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; //将字符串s接到当前字符串末尾 string str2 = &quot;LOL DNP&quot;; str1 += str2; cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; //将字符串接到当前字符串末尾 string str3 = &quot;I&quot;; str3.append(&quot; love &quot;); cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl; //将字符串的前n位接到字符串末尾 str3.append(&quot;game: aaaa&quot;, 6); cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl; //将字符串的第四位开始的后三位接到当前字符串的末尾 string str4 = &quot;LOL DNP 2K&quot;; string str5 = str3; str3.append(str4, 4,3); cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl; //将字符串s接到当前字符串的末尾 str5.append(str4); cout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; endl;&#125; string查找和替换查找：查找指定字符串是否存在然后返回第一个字符的位置。 替换：先找到指定字符串，然后替换字符串(要替换的字符串个数可多于原字符串个数)。 8种查找方式，2种替换方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;using namespace std;#include&lt;string&gt;#if 0*int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找*int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找*int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置*int find(const char c, int pos = 0) const; //查找字符c第一次出现位置*int rfind(const string&amp; str, int pos = npos) const; //查找str最后一次位置,从pos开始查找*int rfind(const char* s, int pos = npos) const; //查找s最后一次出现位置,从pos开始查找*int rfind(const char* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置*int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置*string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str*string&amp; replace(int pos, int n,const char* s); //替换从pos开始的n个字符为字符串s#endifvoid test01()&#123; string str = &quot;abcdefg abcdefgh&quot;; //查找s第一次出现位置,从pos开始查找 int num1 = str.find(&quot;de&quot;,0);//3 cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl; //查找str第一次出现位置,从pos开始查找 string str1 = &quot;efgh&quot;; int num2 = str.find(str1,0);//12 cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl; //从pos位置查找s的前n个字符第一次位置 int num3 = str.find(&quot;efgh&quot;,0,2);//4 cout &lt;&lt; &quot;num3 = &quot; &lt;&lt; num3 &lt;&lt; endl; //查找字符c第一次出现位置 int num4 = str.find(&#x27;g&#x27;, 0);//6 cout &lt;&lt; &quot;num4 = &quot; &lt;&lt; num4 &lt;&lt; endl; cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl; //查找s最后一次出现位置,从pos开始查找 int num5 = str.rfind(&quot;de&quot;, 16);//11 cout &lt;&lt; &quot;num5 = &quot; &lt;&lt; num5 &lt;&lt; endl; //查找str最后一次出现位置,从pos开始查找 string str2 = &quot;efgh&quot;; int num6 = str.rfind(str2, 16);//12 cout &lt;&lt; &quot;num6 = &quot; &lt;&lt; num6 &lt;&lt; endl; //从pos位置查找s的前n个字符最后一次位置 int num7 = str.rfind(&quot;efg&quot;, 16, 2);//12 cout &lt;&lt; &quot;num7 = &quot; &lt;&lt; num7 &lt;&lt; endl; //查找字符c最后一次出现位置 int num8 = str.rfind(&#x27;g&#x27;, 16);//14 cout &lt;&lt; &quot;num8 = &quot; &lt;&lt; num8 &lt;&lt; endl; cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl; //替换从pos开始n个字符为字符串str string str3 = &quot;11111&quot;; str.replace(2,3,str3); cout &lt;&lt; &quot;str = &quot; &lt;&lt; str &lt;&lt; endl; //替换从pos开始的n个字符为字符串s str.replace(12, 2, &quot;111&quot;); cout &lt;&lt; &quot;str = &quot; &lt;&lt; str&lt;&lt;endl;&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; string字符串比较比较方式：逐个按照字符的ASCII码进行对比 数值 返回值 = 返回0 &gt; 返回1 &lt; 返回-1 12345678910111213141516171819void test01()&#123; string str1 = &quot;hello&quot;; string str2 = &quot;hello&quot;; if (str1.compare(str2) == 0) &#123; cout &lt;&lt; &quot;str1与str2相等。&quot; &lt;&lt; endl; &#125; else if (str1.compare(str2) &gt; 0) &#123; cout &lt;&lt; &quot;str1大于str2。&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;str1小于str2。&quot; &lt;&lt; endl; &#125;&#125; string字符存取两种方式： 1.str[i]用下标的方式进行读取和修改 2.str.at(i)来对字符串进行读取和修改 1234567891011121314151617181920212223void test01()&#123; string str = &quot;hello&quot;; //1、通过[]来进行访问 for (int i = 0; i &lt; str.size(); i++) &#123; cout &lt;&lt; str[i] &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl; //2、通过at来进行访问 for (int i = 0; i &lt; str.size(); i++) &#123; cout&lt;&lt;str.at(i)&lt;&lt;&quot; &quot;; &#125; cout &lt;&lt; endl; //3、修改字符 str[0] = &#x27;x&#x27;; cout &lt;&lt; str &lt;&lt; endl; str.at(1) = &#x27;x&#x27;; cout &lt;&lt; str &lt;&lt; endl;&#125; string字符串插入和删除三种方式 1.str.insert(插入位置,插入char字符串) 2.str.insert(插入位置,插入string字符串) 3.str.insert(插入位置,插入字符个数,插入的字符) 4.str.erase(删除的位置,删除的个数) 12345678910111213141516171819202122void test01()&#123; string str = &quot;hello&quot;; //插入和删除字符串 //1、插入char型字符串 str.insert(5,&quot;world&quot;);//插入位置、插入字符串 cout &lt;&lt; str &lt;&lt; endl;//helloworld //2、插入str型字符串 string str1 = &quot; &quot;; str.insert(5,str1);//插入位置、插入字符串 cout &lt;&lt; str &lt;&lt; endl;//hello world //3、插入n个相同的字符 str.insert(0, 2, &#x27;h&#x27;);//插入位置、插入个数、插入字符 cout &lt;&lt; str &lt;&lt; endl;//hhhello world //4、删除字符串 str.erase(0, 2);//删除位置、删除个数 cout &lt;&lt; str &lt;&lt; endl;//hello world&#125; string子串一种用法 1.str.substr(开始位置,获取的字符个数) 12345678910111213141516void test01()&#123; string str = &quot;abcdefg&quot;; string subSTR = str.substr(1, 4); cout &lt;&lt; subSTR &lt;&lt; endl;//bcde&#125;//实用操作void test02()&#123; //从邮件地址中获取用户姓名 string email = &quot;zhangsan@qq.com&quot;; int pos = email.find(&#x27;@&#x27;); string username = email.substr(0, pos); cout &lt;&lt; &quot;username = &quot; &lt;&lt;username&lt;&lt; endl;&#125; vector容器vector与普通数组的区别：数组是静态空间，vector是动态空间（可以扩展） vector构造函数四种方式： 1.vector v；//默认构造函数 2.vectorv1(v.begin(),v.end()); //将v[begin(),end())中间的元素拷贝给v1 3.vectorv2(n,m) //把n个m拷贝给v2 4.vectorv3(v2) //把v2拷贝给v3 1234567891011121314151617181920212223242526272829void printVector(vector&lt;int&gt;&amp;v)&#123; for (vector&lt;int&gt;::iterator it = v.begin(); it!= v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; //1.默认构造函数,无参构造 vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); //2.将v的[begin(),end())拷贝到v2 vector&lt;int&gt;v2(v1.begin(), v1.end()); printVector(v2); //3.将n个相同的元素赋值给v3 vector&lt;int&gt; v3(10, 1000); printVector(v3); //4.拷贝构造 vector&lt;int&gt;v4(v3); printVector(v4);&#125; vector赋值操作三种方式 1.v2=v1; //重载等号赋值 2.v2.assign(v1.begin(),v2.end()); //区间赋值 3.v2.assign(n,m); //n个m赋值 123456789101112131415161718192021222324252627282930void printVector(vector&lt;int&gt;&amp;v)&#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); //1.等号赋值 vector&lt;int&gt;v2 = v1; printVector(v2); //2.区间赋值 vector&lt;int&gt;v3; v3.assign(v2.begin(), v2.end()); printVector(v3); //3.n个m赋值 vector&lt;int&gt;v4; v4.assign(10, 100); printVector(v4);&#125; vector容量与大小五种方式 1.v.empty();//判断容器为空 2.v.szie();//返回容器的大小 3.v.capacity();//返回容器的容量 4.v.resize(n);//如果重新定义的容器长度比原来的容器长度长，那么就默认用0来填充末尾的空位，如果定义的容器长度比原来的容器的长度短，那么超出定义容器长度的部分就会被删除掉 5.v.resize(n,m);//如果重新定义的容器长度比原来的容器长度长，那么就用自己定义的数字m来填充末尾的空位，如果定义的容器长度比原来的容器的长度短，那么超出定义容器长度的部分就会被删除掉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void printVector(vector&lt;int&gt;&amp;v)&#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); //0.判断是否为空 if (v1.empty()) &#123; cout &lt;&lt; &quot;容器为空！&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;容器不为空！&quot; &lt;&lt; endl; &#125; //1.size大小 cout &lt;&lt; &quot;v1的大小为：&quot;&lt;&lt;v1.size() &lt;&lt; endl; //2.capacity容量 cout &lt;&lt; &quot;v1的容量为：&quot;&lt;&lt;v1.capacity() &lt;&lt; endl; //3.重新定义大小,默认用0来填充 v1.resize(15); printVector(v1); cout &lt;&lt; &quot;v1的大小为：&quot; &lt;&lt; v1.size() &lt;&lt; endl; cout &lt;&lt; &quot;v1的容量为：&quot; &lt;&lt; v1.capacity() &lt;&lt; endl; //4.重新定义大小，自定义填充 v1.resize(20,9); printVector(v1); cout &lt;&lt; &quot;v1的大小为：&quot; &lt;&lt; v1.size() &lt;&lt; endl; cout &lt;&lt; &quot;v1的容量为：&quot; &lt;&lt; v1.capacity() &lt;&lt; endl; //5.定义大小比原容器长度短，超出部分自动删除 v1.resize(5); printVector(v1); cout &lt;&lt; &quot;v1的大小为：&quot; &lt;&lt; v1.size() &lt;&lt; endl; cout &lt;&lt; &quot;v1的容量为：&quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#125; vector插入和删除七种方式 1.v.push_back(m);//尾插元素m 2.v.pop_back();//尾删元素m 3.v.insert(pos,m);//在迭代器pos位置插入元素m 4.v.insert(pos,n,m);//在迭代器pos位置插入n个元素m 5.v.erase(pos);//在迭代器pos位置删除一个元素 6.v.erase(begin,end);//在迭代器[begin,end)区间删除元素 7.v.clear();//删除容器中所有元素 12345678910111213141516171819202122232425262728293031323334353637383940void printVector(vector&lt;int&gt;&amp;v)&#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; vector&lt;int&gt;v1; //1.尾插 v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); v1.push_back(50); printVector(v1); //2.尾删 v1.pop_back(); v1.pop_back(); printVector(v1); //3.插入 v1.insert(v1.begin()+1, 100); printVector(v1); //4.插入多元素 v1.insert(v1.begin() + 3, 5, 0); printVector(v1); //5.删除 v1.erase(v1.begin() + 1); printVector(v1); //6.删除多元素 v1.erase(v1.begin() + 2, v1.end()-1); printVector(v1); //7.清空 v1.clear(); printVector(v1);&#125; vector数据存取四种方式： 1.v[i];//输出第i个位置的元素 2.v.at(i)//输出第i个位置的元素 3.v.front()//输出第一个元素 4.v.back()//输出最后一个元素 123456789101112131415161718192021222324252627void test01()&#123; //数据存取 vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; //1.利用[]来进行访问 for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //2.利用at来进行访问 for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //3.输出第一个元素 cout &lt;&lt; &quot;第一个元素为：&quot; &lt;&lt; v1.front() &lt;&lt; endl; //4.输出最后一个元素 cout &lt;&lt; &quot;最后一个元素为：&quot; &lt;&lt; v1.back() &lt;&lt; endl;&#125; vector互换容器一种用法 v1.swap(v2); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void printVector(vector&lt;int&gt;&amp;v)&#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; vector&lt;int&gt;v1; //基本用法 for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl; printVector(v1); vector&lt;int&gt;v2; for (int i = 10; i&gt;0; i--) &#123; v2.push_back(i); &#125; printVector(v2); v1.swap(v2); cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl; printVector(v1); printVector(v2);&#125;void test02()&#123; //实际用法，缩短容量 vector&lt;int&gt;v; for (int i = 0; i &lt; 10000; i++) &#123; v.push_back(i); &#125; cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl; v.resize(3);//重新定义容器v的大小 cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;/*为了不造成资源的浪费，经常用匿名对象来与原对象进行容量互换，匿名对象在使用完后会被系统进行回收，这样就不会造成资源的浪费*/ vector&lt;int&gt;(v).swap(v); cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;&#125; vector预留空间一种语法 v.reserve(n);//n为要放置的元素个数 123456789101112131415161718192021void test01()&#123; vector&lt;int&gt; v; //预留空间 v.reserve(100000); int num = 0; int *p = NULL; for (int i = 0; i &lt; 100000; i++) &#123; v.push_back(i); if (p != &amp;v[0]) &#123; p = &amp;v[0]; num++; &#125; &#125; cout &lt;&lt; &quot;分配的空间次数为：&quot; &lt;&lt; num &lt;&lt; endl; cout &lt;&lt; &quot;容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;&#125; deque容器deque容器的构造函数四种方式 1.d.push_back(i);//push_back构造 2.dequed1(d.begin(),d.end());//区间构造 3.dequed2(n,m);//n个相同元素m构造 4.dequed3(d2);//拷贝构造 1234567891011121314151617181920212223242526272829303132void printDeque(const deque&lt;int&gt;&amp;d)&#123; //如果不希望容器中的数据被修改，要在deque前面加上const //同时在迭代器前面也要加上const_ for (deque&lt;int&gt; :: const_iterator it = d.begin(); it != d.end(); it++) &#123; //*it = 100; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; deque&lt;int&gt;d; //1.push_back构造; for (int i = 0; i &lt; 10; i++) &#123; d.push_back(i); &#125; printDeque(d); //2.区间构造 deque&lt;int&gt;d1(d.begin(), d.end()); printDeque(d1); //3.n个相同元素构造 deque&lt;int&gt;d2(10, 100); printDeque(d2); //4.拷贝构造 deque&lt;int&gt;d3(d2); printDeque(d3);&#125; deque容器的赋值操作三种方式： 1.d1=d;//等号赋值 2.d2=d.assign(d.begin(),d.end());//assign区间赋值 3.d2=d.assign(n,m);//assign赋值n个m 1234567891011121314151617181920void test01()&#123; deque&lt;int&gt;d; for (int i = 0; i &lt; 10; i++) &#123; d.push_back(i); &#125; printDeque(d); deque&lt;int&gt;d1 = d; printDeque(d1); deque&lt;int&gt;d2; d2.assign(d.begin(), d.end()); printDeque(d2); deque&lt;int&gt;d3; d3.assign(10,1000); printDeque(d3);&#125; deque容器的大小操作1.d.empty();//判断容器为空 2.d.szie();//返回容器的大小 3.deque为两端数组，没有容量可言 4.d.resize(n);//如果重新定义的容器长度比原来的容器长度长，那么就默认用0来填充末尾的空位，如果定义的容器长度比原来的容器的长度短，那么超出定义容器长度的部分就会被删除掉 5.d.resize(n,m);//如果重新定义的容器长度比原来的容器长度长，那么就用自己定义的数字m来填充末尾的空位，如果定义的容器长度比原来的容器的长度短，那么超出定义容器长度的部分就会被删除掉 12345678910111213141516171819202122232425262728293031void test01()&#123; deque&lt;int&gt;d; for (int i = 0; i &lt; 10; i++) &#123; d.push_back(i); &#125; printDeque(d); //1.判断容量是否为空 if (d.empty()) &#123; cout &lt;&lt; &quot;d为空！&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;d不为空！&quot; &lt;&lt; endl; &#125; //2.容器大小 cout &lt;&lt; &quot;d的大小为：&quot; &lt;&lt; d.size() &lt;&lt; endl; //3.重新定义容器大小,默认填充为0 d.resize(15); printDeque(d); d.resize(20, 5);//自定义填充为5 printDeque(d); d.resize(5); printDeque(d);&#125; deque容器的插入和删除七种语法 1.d.push_front(m);//头插 2.d.push_back(m);//尾插 3.d.pop_front();//头删 4.d.pop_back();//尾删 5.d.insert(pos,m);//在pos插入元素m d.insert(pos ,n,m);//在pos插入n个m d.insert(pos, d1.begin(), d1.end());//在pos插入另一个容器的某一段元素 6.d.erase(pos);//删除pos位置的元素 d.erase(d.begin() ,d.end());//左开右闭 7.d.clear();//清空 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void test01()&#123; deque&lt;int&gt;d; for (int i = 0; i &lt; 10; i++) &#123; d.push_back(i); &#125; printDeque(d); //0 1 2 3 4 5 6 7 8 9 //1.头插 d.push_front(100); d.push_front(200); //2.尾插 d.push_back(10); d.push_back(20); printDeque(d); //200 100 0 1 2 3 4 5 6 7 8 9 10 20 //3.头删 d.pop_front(); d.pop_front(); //4.尾删 d.pop_back(); d.pop_back(); printDeque(d); //0 1 2 3 4 5 6 7 8 9 //5.插入 d.insert(d.begin()+3,9); printDeque(d); // 0 1 2 9 3 4 5 6 7 8 9 d.insert(d.begin()+5 ,3,7); printDeque(d); // 0 1 2 9 3 777 4 5 6 7 8 9 deque&lt;int&gt;d1; d1.push_back(1); d1.push_back(2); d1.push_back(3); d.insert(d.begin() + 6, d1.begin(), d1.end()); printDeque(d); // 0 1 2 9 3 7 123 77 4 5 6 7 8 9 //6.删除 d.erase(d.begin()+3); d.erase(d.begin() + 4,d.begin()+10);//左开右闭 printDeque(d); // 0 1 2 3 4 5 6 7 8 9 //7.清空 d.clear(); printDeque(d);&#125; deque容器的数据存取四种语法 1.d[i];//访问第i个元素 2.d.at(i);//访问第i个元素 3.d.front();//访问首个元素 4.d.back();//访问末个元素 123456789101112131415161718192021222324252627void test01()&#123; deque&lt;int&gt;d; d.push_back(10); d.push_back(20); d.push_back(30); d.push_front(100); d.push_front(200); d.push_front(300); //1.通过[]来访问 for (int i = 0; i &lt; d.size(); i++) &#123; cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //2.通过at来访问 for (int i = 0; i &lt; d.size(); i++) &#123; cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //3.首元素 cout &lt;&lt; &quot;d的首个元素为：&quot; &lt;&lt; d.front() &lt;&lt; endl; //4.末元素 cout &lt;&lt; &quot;d的末个元素为：&quot; &lt;&lt; d.back() &lt;&lt; endl;&#125; deque容器排序一种语法： 1.sort(d.begin(),d.end());//默认排序为升序 1234567891011121314151617void test01()&#123; deque&lt;int&gt;d; d.push_back(10); d.push_back(20); d.push_back(30); d.push_front(100); d.push_front(200); d.push_front(300); cout &lt;&lt; &quot;排序前：&quot; &lt;&lt; endl; printDeque(d); //默认排序为升序 sort(d.begin(), d.end()); cout &lt;&lt; &quot;排序后：&quot; &lt;&lt; endl; printDeque(d);&#125; 案例112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Person&#123;public: Person(string name, int score) &#123; m_name = name; m_score = score; &#125; string m_name; int m_score;&#125;;void creatPerson(vector&lt;Person&gt;&amp;v)&#123; string nameSeed = &quot;ABCDE&quot;;//名字种子 for (int i = 0; i &lt; 5; i++) &#123; string name = &quot;选手&quot;; name += nameSeed[i]; Person p(name, 0); v.push_back(p); &#125;&#125;void setScore(vector&lt;Person&gt;&amp;v)&#123; for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; deque&lt;int&gt;d; for (int i = 0; i &lt; 10; i++) &#123; int score = rand() % 41 + 60; d.push_back(score); &#125; cout &lt;&lt; it-&gt;m_name &lt;&lt; endl; cout &lt;&lt; &quot;10位老师的评分分别为：&quot; &lt;&lt; endl; for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++) &#123; cout &lt;&lt; *dit &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //排序 sort(d.begin(), d.end());//不要打成back() //去掉最高分和最低分 d.pop_back(); d.pop_front(); //求平均分 int sum = 0; for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++) &#123; sum += *dit; &#125; int average = sum / d.size(); it-&gt;m_score = average; &#125; &#125;void showPerson(vector&lt;Person&gt;&amp;v)&#123; cout &lt;&lt; &quot;-----------------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;姓名\\t&quot; &lt;&lt; &quot;成绩\\t&quot; &lt;&lt; endl; for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; (*it).m_name &lt;&lt; &quot;\\t&quot;&lt;&lt;it-&gt;m_score&lt;&lt;&quot;\\t&quot;; cout &lt;&lt; endl; &#125; &#125;void test01()&#123; vector&lt;Person&gt;v; creatPerson(v); setScore(v); showPerson(v);&#125; stack容器stack容器的基本概念特点：栈容器，先进后出，不允许遍历，可以判断是否为空，可以输出容器大小 stack容器的常用接口1.构造函数： stackstk;//默认构造函数 stackstk(stk1);//拷贝构造函数 2.赋值操作： stk1=stk2;//等号赋值 3.数据存取： s.push(m);//数据m入栈 s.pop();//栈顶元素出栈 s.top();//返回栈顶元素 4.大小操作： s.empty();//判断堆栈是否为空 s.size();//返回栈的大小 1234567891011121314151617181920212223void test01()&#123; //默认构造函数 stack&lt;int&gt; s; //赋值函数 s.push(10); s.push(20); s.push(30); s.push(40); //拷贝构造函数 stack&lt;int&gt;s1 = s; //判断是否为空,输出栈顶元素 while (!s1.empty()) &#123; cout &lt;&lt; &quot;栈顶元素为：&quot; &lt;&lt; s1.top() &lt;&lt; endl; //出栈 s1.pop(); &#125; //输出stack容器的大小 cout &lt;&lt; &quot;stack容器的大小为:&quot; &lt;&lt; s1.size() &lt;&lt; endl;&#125; queue 容器特点：两端数组，先进先出，可以访问是否为空，可以访问队列大小，不可以访问队列容量。 queue容器的常用接口八个常用接口： 1.queueq;//默认构造 2.queueq(q1);//拷贝构造 3.q2=q1;//赋值操作 4.q.empty();//判断是否为空 5.q.size();//容器大小 6.q.push();//入队 7.q.pop();//出队 8.q.front();//访问对手元素 9.q.back();//访问队末元素 1234567891011121314151617181920212223242526272829void test01()&#123; //队列，先进先出 //1.默认构造 queue&lt;person&gt; q; person p1(&quot;唐僧&quot;,30); person p2(&quot;孙悟空&quot;, 500); person p3(&quot;猪八戒&quot;, 30); person p4(&quot;沙僧&quot;, 30); //2.入队操作 q.push(p1); q.push(p2); q.push(p3); q.push(p4); //3.拷贝构造 queue&lt;person&gt;q1(q); //4.显示队头元素，对尾元素 while (!q.empty()) &#123; //队头元素 cout &lt;&lt; &quot;队头元素：&quot; &lt;&lt; &quot;姓名：&quot; &lt;&lt; q.front().m_name &lt;&lt; &quot;年龄：&quot; &lt;&lt; q.front().m_age &lt;&lt; endl; //队尾元素 cout &lt;&lt; &quot;队尾元素：&quot; &lt;&lt; &quot;姓名：&quot; &lt;&lt; q.back().m_name &lt;&lt; &quot;年龄：&quot; &lt;&lt; q.back().m_age &lt;&lt; endl; //显示队列大小 cout &lt;&lt; &quot;队列大小为：&quot; &lt;&lt; q.size() &lt;&lt; endl; //出队 q.pop(); &#125;&#125; list容器特点：链表，由一系列结点组成。 结点的组成：一个用来存取数据的数据域，一个用来存取地址的指针域。 list容器的构造函数四种语法： 1.listl1;//默认构造 2.listl2(l1.begin(),l2.end());//区间构造 3.listl3(l1);//拷贝构造 4.listl4(n,m);//n个m构造 1234567891011121314151617181920void test01()&#123; //默认构造 list&lt;int&gt;l1; l1.push_back(10); l1.push_back(20); l1.push_back(30); l1.push_back(40); printList(l1); //区间构造 list&lt;int&gt;l2(l1.begin(), l1.end()); printList(l2); //拷贝构造 list&lt;int&gt;l3(l1); printList(l3); //n个m构造 list&lt;int&gt;l4(10, 20); printList(l4);&#125; list容器的赋值和交换四种语法： 1.l2=l1;//等号赋值 2.l3.assign(l1.begin(),l2.end());//assign区间赋值 3.l4.assign(n,m);//assign中n个m赋值 4.l4.swap(l3);//交换 123456789101112131415161718192021222324252627282930void test01()&#123; list&lt;int&gt;l1; l1.push_back(10); l1.push_back(20); l1.push_back(30); l1.push_back(40); printList(l1); //1.等号赋值 list&lt;int&gt;l2; l2 = l1; printList(l2); //2.assign区间赋值 list&lt;int&gt;l3; l3.assign(++l1.begin(), l1.end()); printList(l3); //3.assign多个m赋值 list&lt;int&gt;l4; l4.assign(10, 20); printList(l4); //4.交换 cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl; printList(l3); printList(l4); l3.swap(l4); cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl; printList(l3); printList(l4);&#125; list容器的大小操作四种语法： 1.l.empty();//判断容器为空 2.l.szie();//返回容器的大小 3.v.resize(n);//如果重新定义的容器长度比原来的容器长度长，那么就默认用0来填充末尾的空位，如果定义的容器长度比原来的容器的长度短，那么超出定义容器长度的部分就会被删除掉 4.v.resize(n,m);//如果重新定义的容器长度比原来的容器长度长，那么就用自己定义的数字m来填充末尾的空位，如果定义的容器长度比原来的容器的长度短，那么超出定义容器长度的部分就会被删除掉 1234567891011121314151617181920212223242526272829void test01()&#123; list&lt;int&gt;l1; l1.push_back(10); l1.push_back(20); l1.push_back(30); l1.push_back(40); printList(l1); //1.判断是否为空 if (l1.empty()) &#123; cout &lt;&lt; &quot;l1为空！&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;l1不为空！&quot; &lt;&lt; endl; //2.输出容器元素个数 cout &lt;&lt; &quot;容器中的元素个数为：&quot; &lt;&lt; l1.size() &lt;&lt; endl; &#125; //3.重新定义容器大小，默认填充为0； l1.resize(10); printList(l1); //4.重新定义容器大小，自定义填充 l1.resize(15,100); printList(l1); l1.resize(5); printList(l1);&#125; list容器的插入和删除十一种语法： 1 l.push_back(m);//在容器尾部插入一个元素2 l.pop_back();//在容器尾部删除一个元素3 l.push_front(m);//在容器头部插入一个元素4 l.pop_front();//在容器头部删除一个元素5 l.insert(pos,m);//在容器pos位置插入一个元素6 l.insert(pos, n,m);//在容器pos位置插入n个相同的元素m7 l.insert(pos, l1.begin(),l2.end());//在容器pos位置插入区间元素8 l.clear();//移除容器私有数据9 l.erase(l.begin(),l.end());//删除区间元素10 l.erase(pos);//删除pos位置的元素11 l.remove(m);//删除容器中所有与m匹配的元素 123456789101112131415161718192021222324252627282930313233343536373839404142void test01()&#123; list&lt;int&gt;l1; //尾插 l1.push_back(10); l1.push_back(20); l1.push_back(30); l1.push_back(40); //头插 l1.push_front(100); l1.push_front(200); l1.push_front(300); l1.push_front(400); list&lt;int&gt;l2=l1; printList(l1); //头删 l1.pop_front(); //尾删 l1.pop_back(); printList(l1); //中部插入 l1.insert(++l1.begin(), 1000); printList(l1); //中部插入 l1.insert(++l1.begin(),5, 555); printList(l1); //中部插入 l1.insert(++l1.begin(), l2.begin(), l2.end()); printList(l1); //删除相同元素 l1.remove(555); printList(l1); //删除区间元素,注意迭代器只能够前移或者后移 l1.erase(++l1.begin(),--l1.end()); printList(l1); //删除单个元素 l1.erase(l1.begin()); printList(l1); //清空元素 l1.clear(); printList(l1);&#125; list容器的数据存取两种语法： 1.l.front();//访问第一个元素 2.l.back();//访问最后一个元素 1234567891011void test01()&#123; list&lt;int&gt; l1; l1.push_back(10); l1.push_back(20); l1.push_back(30); l1.push_back(40); cout &lt;&lt; &quot;第一个元素为：&quot; &lt;&lt; l1.front() &lt;&lt; endl; cout &lt;&lt; &quot;最后一个元素为：&quot; &lt;&lt; l1.back() &lt;&lt; endl;&#125; list容器的反转和排序两种语法： 1.l.reverse();//反转 2.l.sort();//排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344void printList(const list&lt;int&gt;&amp;l)&#123; for (list&lt;int&gt;::const_iterator it = l.begin(); it != l.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt;&quot; &quot;; &#125; cout &lt;&lt; endl;&#125;bool myCompare(int v1,int v2)&#123; return v1 &gt; v2;&#125;void test01()&#123; list&lt;int&gt; l1; l1.push_back(20); l1.push_back(10); l1.push_back(30); l1.push_back(50); l1.push_back(30); printList(l1); //反转 l1.reverse(); printList(l1); //排序,所有不支持随机访问迭代器的容器，不可以用标准算法 //不支持随机访问迭代器的容器，内部会提供算法 //默认从小到大 l1.sort(); printList(l1); //降序排列 l1.sort(myCompare); printList(l1);&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; list容器的排序案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;using namespace std;#include&lt;list&gt;#include&lt;string&gt;class Person&#123;public: Person(string name, int age, int height) &#123; m_name = name; m_age = age; m_height = height; &#125; string m_name; int m_age; int m_height;&#125;;bool compare(Person p1, Person p2)&#123; if (p1.m_age == p2.m_age) &#123; return p1.m_height &gt; p2.m_height; &#125; else return p1.m_age &lt; p2.m_age;&#125;void test01()&#123; list&lt;Person&gt;l1; Person p1(&quot;张三&quot;, 20, 185); Person p2(&quot;李四&quot;, 34, 145); Person p3(&quot;王五&quot;, 12, 186); Person p4(&quot;赵丽&quot;, 20, 165); Person p5(&quot;安庆&quot;, 20, 167); Person p6(&quot;王八&quot;, 25, 134); l1.push_back(p1); l1.push_back(p2); l1.push_back(p3); l1.push_back(p4); l1.push_back(p5); l1.push_back(p6); cout &lt;&lt; &quot;排序前：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;姓名\\t&quot; &lt;&lt; &quot;年龄\\t&quot; &lt;&lt; &quot;身高\\t&quot; &lt;&lt; endl; for (list&lt;Person&gt;::const_iterator it = l1.begin(); it != l1.end();it++) &#123; cout &lt;&lt; (*it).m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; (*it).m_age &lt;&lt; &quot;\\t&quot; &lt;&lt; (*it).m_height &lt;&lt; endl; &#125; l1.sort(compare); cout &lt;&lt; &quot;排序后：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;姓名\\t&quot; &lt;&lt; &quot;年龄\\t&quot; &lt;&lt; &quot;身高\\t&quot; &lt;&lt; endl; for (list&lt;Person&gt;::const_iterator it = l1.begin(); it != l1.end(); it++) &#123; cout &lt;&lt; (*it).m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; (*it).m_age &lt;&lt; &quot;\\t&quot; &lt;&lt; (*it).m_height &lt;&lt; endl; &#125;&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; set/ multiset 容器特点：所有元素在插入后会被自动排序，set和multiset都属于关联式容器，底层结构都是用二叉树实现。 set不允许容器有重复元素，重复元素只显示一个。 multiset允许有重复元素。 set容器构造和赋值三种语法： 1.set s1;//默认构造 2.sets2(s1);//拷贝构造 3.s3=s1;//等号赋值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void printSet(const set&lt;int&gt; &amp;st)&#123; for (set&lt;int&gt;::const_iterator it = st.begin(); it != st.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void printmSet(const multiset&lt;int&gt; &amp;st)&#123; for (multiset&lt;int&gt;::const_iterator it = st.begin(); it != st.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; //默认构造 set&lt;int&gt; st; //插入数据 st.insert(50); st.insert(40); st.insert(30); st.insert(10); st.insert(90); //打印数组 printSet(st); //自动排序，由小到大,但是set不允许有重复元素，重复元素会被覆盖 //拷贝构造 set&lt;int&gt; s1(st); printSet(st); //赋值函数 set&lt;int&gt; s2 = st; printSet(st); //multiset允许有重复元素 multiset&lt;int&gt; m1; m1.insert(50); m1.insert(40); m1.insert(30); m1.insert(10); m1.insert(30); printmSet(m1);&#125; set容器大小和交换三种语法： 1.st.empty();//判断是否为空 2.st.size();//返回容器大小 3.st.swap{st2};//交换容器 1234567891011121314151617181920212223242526272829303132333435363738void test01()&#123; set&lt;int&gt; st; //插入数据 st.insert(50); st.insert(40); st.insert(30); st.insert(10); st.insert(90); //打印数组 printSet(st); if (st.empty()) &#123; cout &lt;&lt; &quot;容器为空！&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;容器不为空！&quot; &lt;&lt; endl; cout &lt;&lt; &quot;容器的大小为：&quot; &lt;&lt; st.size() &lt;&lt; endl; &#125; set&lt;int&gt; m1; m1.insert(500); m1.insert(400); m1.insert(300); m1.insert(100); m1.insert(200); cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl; printSet(st); printSet(m1); cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl; st.swap(m1); printSet(st); printSet(m1);&#125; set容器插入和删除五种语法： 1.st.insert(m);//插入元素 2.st.erase(pos);//删除pos位置的元素 3.st.erase(st.begin(),st,end());//区间删除 4.st.erase(m);//根据元素数值删除元素 5.st.clear();//清空元素 12345678910111213141516171819202122232425262728void test01()&#123; set&lt;int&gt; st; //插入数据 st.insert(50); st.insert(40); st.insert(30); st.insert(10); st.insert(90); st.insert(70); //打印数组 printSet(st); //删除元素,删除排序后的容器 st.erase(st.begin()); printSet(st); //根据元素数值删除元素 st.erase(30); printSet(st); //区间删除 st.erase(++st.begin(),--st.end()); printSet(st); //清空操作 st.clear(); printSet(st);&#125; set容器查找和统计两种语法： 1.st.find(m);//查找元素m，如果存在的话返回m的迭代器位置，没有的话返回end(). 2.st.count(m);//统计元素m的个数，要么1要么0 12345678910111213141516171819202122232425void test01()&#123; set&lt;int&gt; st; //插入数据 st.insert(50); st.insert(40); st.insert(30); st.insert(10); st.insert(90); st.insert(70); //查找元素 set&lt;int&gt;::iterator pos = st.find(50); if (pos != st.end()) &#123; cout &lt;&lt; &quot;找到元素：&quot; &lt;&lt; *pos &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;没有找到元素！&quot; &lt;&lt; endl; &#125; //统计元素个数 int sum = st.count(50); cout &lt;&lt; &quot;元素个数为：&quot; &lt;&lt; sum &lt;&lt; endl;&#125; set和multiset的区别区别： set容器插入数据后会返回插入是否成功的布尔类型，不可以重复插入。 multiset可以重复插入数据，但不会返回插入是否成功的布尔类型。 12345678910111213141516171819202122232425262728293031323334353637383940void test01()&#123; set&lt;int&gt; st; //set容器会返回插入是否成功的布尔类型，不可以重复插入 pair&lt;set&lt;int&gt;::iterator, bool&gt; ret; ret = st.insert(10); if (ret.second) &#123; cout &lt;&lt; &quot;插入数据成功！&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;插入失败！&quot; &lt;&lt; endl; &#125; ret = st.insert(10); if (ret.second) &#123; cout &lt;&lt; &quot;插入数据成功！&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;插入失败！&quot; &lt;&lt; endl; &#125; //multiset可以重复插入数据 multiset&lt;int&gt; m; m.insert(10); m.insert(10); m.insert(10); m.insert(10); for (multiset&lt;int&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; pair对组创建两种语法： 1.pair&lt;T,T&gt;p1(T,T); 2.pair&lt;T,T&gt;p2=make_pair(T,T); 1234567891011void test01()&#123; //第一种方式 pair&lt;string, int&gt;p1(&quot;Tom&quot;, 20); cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p1.first &lt;&lt; &quot;年龄：&quot; &lt;&lt; p1.second &lt;&lt; endl; //第二种方式 pair&lt;string, int&gt;p2 = make_pair(&quot;Jerry&quot;, 30); cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p2.first &lt;&lt; &quot;年龄：&quot; &lt;&lt; p2.second &lt;&lt; endl;&#125; set容器排序set容器默认排序方法为：由小到大 可以利用仿函数的方法来改变排序规则 123456789101112131415161718192021222324252627282930313233343536373839//用仿函数改变排序方式class mycompare&#123;public: bool operator()(int v1, int v2) &#123; return v1 &gt; v2; &#125;&#125;;void test01()&#123; set&lt;int&gt;s1; s1.insert(10); s1.insert(50); s1.insert(40); s1.insert(20); s1.insert(30); for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; set&lt;int, mycompare&gt;s2; s2.insert(10); s2.insert(50); s2.insert(40); s2.insert(30); s2.insert(20); for (set&lt;int,mycompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041class Person&#123;public: Person(string name, int age) &#123; m_name = name; m_age = age; &#125; string m_name; int m_age;&#125;;class comparePerson&#123;public: bool operator()(const Person&amp;p1,const Person&amp;p2) &#123; //按照年龄降序排序 return p1.m_age &gt; p2.m_age; &#125;&#125;;void test01()&#123; set&lt;Person,comparePerson&gt; s1; Person p1(&quot;刘备&quot;,30); Person p2(&quot;张飞&quot;, 26); Person p3(&quot;关羽&quot;, 28); Person p4(&quot;赵云&quot;, 21); s1.insert(p1); s1.insert(p2); s1.insert(p3); s1.insert(p4); for (set&lt;Person, comparePerson&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123; cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; it-&gt;m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;年龄：&quot; &lt;&lt; it-&gt;m_age &lt;&lt; endl; &#125;&#125; map/ multimap容器map容器基本概念特点：关联式容器，底层结构为二叉树，map容器所有的元素都是pair，pair的第一个元素为键值(key)，pair的第二个元素为实值(value)，所有的元素会按照元素的键值升序排序。 map和multimap的区别： map不允许有重复元素，multimap允许有重复元素。 map容器的构造和赋值三种语法： 1.map&lt;T,T&gt;m;//默认构造 2.map&lt;T,T&gt;m1(m);//拷贝构造 3.map&lt;T,T&gt;m2=m1;//等号赋值 12345678910111213141516171819202122232425262728void printMap( const map&lt;int,int&gt;&amp;m)&#123; for (map&lt;int, int&gt;::const_iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; &quot;key = &quot; &lt;&lt; (*it).first &lt;&lt; &quot;\\tvalue = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; //默认构造函数 map&lt;int, int&gt; m; //插入元素 m.insert(pair&lt;int,int&gt;(1,10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(4, 40)); m.insert(pair&lt;int, int&gt;(3, 30)); //按照键值的大小升序排序 printMap(m); //拷贝构造 map&lt;int, int&gt;m1(m); printMap(m1); //等号赋值 map&lt;int, int&gt;m2 = m; printMap(m2);&#125; map容器的大小和交换三种语法： 1.m.empty();//判断是否为空 2.m.size();//容器的大小 3.m.swap(m2);//交换容器 12345678910111213141516171819202122232425262728293031323334void test01()&#123; map&lt;int, int&gt; m; //插入元素 m.insert(pair&lt;int,int&gt;(1,10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(4, 40)); m.insert(pair&lt;int, int&gt;(3, 30)); //大小操作，判断是否为空 if (m.empty()) &#123; cout &lt;&lt; &quot;m为空！&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;m不为空！&quot; &lt;&lt; endl; cout &lt;&lt; &quot;容器m的大小为：&quot; &lt;&lt; m.size() &lt;&lt; endl; &#125; //交换容器 map&lt;int, int&gt; m2; m2.insert(pair&lt;int, int&gt;(10, 100)); m2.insert(pair&lt;int, int&gt;(20, 200)); m2.insert(pair&lt;int, int&gt;(40, 400)); cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl; printMap(m); printMap(m2); m.swap(m2); cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl; printMap(m); printMap(m2);&#125; map容器的插入和删除八种语法 1.m.insert(pair&lt;T,T&gt;(n,a));//插入元素，推荐使用,n是键值,a是实值 2.m.insert(make_pair(n,a));//插入元素，推荐使用 3.m.insert(map&lt;T,T&gt;::value_type(n,a));//插入元素，不建议使用 4.m[n]=a;//[]插入元素，不建议使用 5.m.erase(beg,end);//区间删除 6.m.erase(pos);//位置删除 7.m.erase(key);//键值删除 8.m.clear();//清空操作 12345678910111213141516171819202122232425262728293031void test01()&#123; //默认构造函数 map&lt;int, int&gt; m; //插入元素，四种方法 //第一种方法 m.insert(pair&lt;int,int&gt;(1,10)); //第二种方法 m.insert(make_pair(2,20)); //第三种方法 m.insert(map&lt;int,int&gt;::value_type(4,40)); //第四种方法，不推荐使用,[]的方法主要是为了访问容器中的元素 m[3] = 50; cout &lt;&lt; m[4] &lt;&lt; endl; //打印容器 printMap(m); //区间删除 m.erase(++m.begin(), --m.end()); printMap(m); //位置删除 m.erase(m.begin()); printMap(m); //键值删除 m.erase(4); printMap(m); //清空操作 m.clear();&#125; map容器的查找和统计两种语法： 1.m.find(m);//查找元素m，查找成功后返回数据位置的迭代器，查找失败则返回末位元素的迭代器。 2.m.court(m);//统计元素m的个数，map里面结果要么为0，要么为1，multimap则不同。 12345678910111213141516171819202122232425262728293031323334void test01()&#123; map&lt;int, int&gt;m; //插入元素 m.insert(pair&lt;int, int&gt;(1,10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); //查找元素 map&lt;int,int&gt;::iterator it=m.find(3); if (it != m.end()) &#123; cout &lt;&lt; &quot;找到元素。key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;\\tvalue = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;未能找到元素。&quot; &lt;&lt; endl; &#125; //统计元素个数 int num = m.count(1); cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl; //multimap中统计元素个数 multimap&lt;int, int&gt;mlm; mlm.insert(pair&lt;int, int&gt;(1,10)); mlm.insert(pair&lt;int, int&gt;(2, 20)); mlm.insert(pair&lt;int, int&gt;(3, 30)); mlm.insert(pair&lt;int, int&gt;(2, 20)); int num1 = mlm.count(2); cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;&#125; map容器排序利用仿函数写函数重载可以实现自定义容器排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class compare&#123;public: bool operator()(int v1,int v2) &#123; //降序排序 return v1 &gt; v2; &#125;&#125;;class Person&#123;public: Person(string name,int id,int age) &#123; m_name = name; m_age = age; m_id = id; &#125; string m_name; int m_age; int m_id;&#125;;void test01()&#123; map&lt;int, Person,compare&gt;m; Person p1(&quot;詹姆斯&quot;, 23,35); Person p2(&quot;科比&quot;, 24,36); Person p3(&quot;奥尼尔&quot;, 32,38); Person p4(&quot;杜兰特&quot;, 35,35); Person p5(&quot;加内特&quot;, 21,39); //插入元素 m.insert(pair&lt;int, Person&gt;(p1.m_id, p1)); m.insert(pair&lt;int, Person&gt;(p2.m_id, p2)); m.insert(pair&lt;int, Person&gt;(p3.m_id, p3)); m.insert(pair&lt;int, Person&gt;(p4.m_id, p4)); m.insert(pair&lt;int, Person&gt;(p5.m_id, p5)); //打印元素 for (map&lt;int, Person&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; &quot;号码：&quot; &lt;&lt; it-&gt;second.m_id &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;second.m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;年龄：&quot; &lt;&lt; it-&gt;second.m_age &lt;&lt; endl; &#125;&#125; 案例21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;using namespace std;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;map&gt;class Worker&#123;public: string m_name; int m_salary; int m_id;&#125;;void InsertWorker(vector&lt;Worker&gt;&amp;vWorker)&#123; string Nameseed = &quot;ABCDEFGHIJ&quot;; for (int i = 0; i &lt; 10; i++) &#123; Worker worker; string name = &quot;员工&quot;; name += Nameseed[i]; worker.m_name = name;//员工姓名 worker.m_id = rand() % 3;//随机产生员工id worker.m_salary = rand() % 10000 + 10000;//随机产生员工工资 vWorker.push_back(worker); &#125;&#125;void InsertmWorker(const vector&lt;Worker&gt;&amp;vWorker, multimap&lt;int, Worker&gt;&amp;mWorker)&#123; for (vector&lt;Worker&gt;::const_iterator it = vWorker.begin(); it != vWorker.end(); it++) &#123; mWorker.insert(make_pair(it-&gt;m_id,*it)); &#125;&#125;void test01()&#123; //1.创建vector容器 vector&lt;Worker&gt;vWorker; //2.插入worker元素 InsertWorker(vWorker); //测试 //for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++) //&#123; // cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;m_name &lt;&lt; &quot;\\t工资：&quot; &lt;&lt; it-&gt;m_salary &lt;&lt; endl; //&#125; //3.创建multimap容器 multimap&lt;int, Worker&gt;mWorker; //4插入元素 InsertmWorker(vWorker,mWorker); //5.显示元素 for (multimap&lt;int, Worker&gt;::iterator it = mWorker.begin(); it != mWorker.end(); it++) &#123; if (it-&gt;second.m_id == 0) &#123; cout &lt;&lt; &quot;策划部\\t&quot; &lt;&lt; it-&gt;second.m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; it-&gt;second.m_salary &lt;&lt; endl; &#125; else if (it-&gt;second.m_id == 1) &#123; cout &lt;&lt; &quot;运营部\\t&quot; &lt;&lt; it-&gt;second.m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; it-&gt;second.m_salary &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;技术部\\t&quot; &lt;&lt; it-&gt;second.m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; it-&gt;second.m_salary &lt;&lt; endl; &#125; &#125;&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++06_STL初识","date":"2020-08-08T08:32:40.000Z","path":"2020/08/08/C-06-STL初识/","text":"STL初识 STL的基本概念 STL(Standard Template Library)标准模板库 STL几乎所有的代码都使用了模板类和模板函数 STL的六大部件六大部件：容器、算法、迭代器、仿函数、适配器、空间配置器 容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据 算法：各种常用算法，如sort、find、copy、for_each等 迭代器：容器和算法之间的胶合剂 仿函数：行为类似数，可最作为算法的某种策略 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西 空间适配器：负责空间的配置与管理 STL的容器、算法、迭代器容器容器：置物之容所 STL容器：将运用最广泛的一些数据结构（数组、链表、树、栈、队列、集合、映射表）实现出来 容器可分为序列式容器和关联式容器两种： 序列式容器：强调值的排序，序列式容器中的每个元素都有固定的位置 关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系 算法算法（Algorithm）：问题之解法 算法又分为质变算法和非质变算法两种： 质变算法：是指运算过程中会更改区间内的元素的内容（拷贝、替换、删除） 非质变算法：是指运算过程中不会改变区间内元素的内容（查找、计数、遍历、寻找极值） 迭代器迭代器：容器和算法之间的粘合剂 提供一种方法，使之既可以依序寻访某个容器所含的各个元素，又无需暴露给容器的内部表示方式，迭代器非常类似指针。 种类 功能 支持运算 输入迭代器 只读 ++、==、！= 输出迭代器 只写 ++ 前向迭代器 读写，只能向前推进 ++、==、！= 双向迭代器 读写，能向前和向后推进 ++、– 随机访问迭代器 读写，可以以跳跃的方式访问任意数据 ++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;= 常用的容器迭代器有双向迭代器、随机访问迭代器 STL容器算法迭代器初识vector存放内置数据类型容器：vector 算法：for_each 迭代器：vector: :iterator 具体案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;#include&lt;vector&gt;//标准容器头文件#include&lt;algorithm&gt;//标准算法头文件void myprint(int val)&#123; cout &lt;&lt; val &lt;&lt; endl;&#125;void test01()&#123; vector&lt;int&gt; v;//创建一个容量，数组 //尾插法添加一些数据 v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); v.push_back(50); //把这些数据显示出来 //第一种遍历方式： cout &lt;&lt; &quot;第一种遍历方式：-------------&quot; &lt;&lt; endl; vector&lt;int&gt;::iterator itBegin = v.begin();//起始迭代器，指向容器的第一个元素 vector&lt;int&gt;::iterator itEnd = v.end();//末尾迭代器，指向容器的最后一个元素的下一个位置 while (itBegin!=itEnd) &#123; cout &lt;&lt; *itBegin &lt;&lt; endl; itBegin++; &#125; //第二种遍历方式 cout &lt;&lt; &quot;第二种遍历方式：-------------&quot; &lt;&lt; endl; for (vector&lt;int&gt;::iterator itBegin2 = v.begin(); itBegin2 != v.end(); itBegin2++) &#123; cout &lt;&lt; *itBegin2 &lt;&lt; endl; &#125; //第三种遍历方式 cout &lt;&lt; &quot;第三种遍历方式：-------------&quot; &lt;&lt; endl; for_each(v.begin(),v.end(),myprint);//for_each(初始迭代器，末尾迭代器，实现函数名)&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; vector存放自定义数据类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;using namespace std;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;string&gt;class person&#123;public: class person(int age,string name) &#123; m_age = age; m_name = name; &#125; int m_age; string m_name;&#125;;void myprint(person &amp;p)&#123; cout &lt;&lt; p.m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; p.m_age &lt;&lt; &quot;\\t&quot; &lt;&lt; endl;&#125;//存放自定义数据void test01()&#123; vector&lt;person&gt; v; //添加数据 person p1(18, &quot;张三&quot;); person p2(19, &quot;李四&quot;); person p3(20, &quot;王五&quot;); v.push_back(p1); v.push_back(p2); v.push_back(p3); cout &lt;&lt; &quot;姓名\\t&quot; &lt;&lt; &quot;年龄\\t&quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myprint);&#125;//存放自定义数据指针void test02()&#123; vector&lt;person*&gt; v; //添加数据 person p1(18, &quot;张三&quot;); person p2(19, &quot;李四&quot;); person p3(20, &quot;王五&quot;); v.push_back(&amp;p1); v.push_back(&amp;p2); v.push_back(&amp;p3); cout &lt;&lt; &quot;姓名2\\t&quot; &lt;&lt; &quot;年龄2\\t&quot; &lt;&lt; endl; //for_each(v.begin(), v.end(), myprint); for (vector&lt;person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; (*it)-&gt;m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; (*it)-&gt;m_age &lt;&lt; &quot;\\t&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; vector容器嵌套容器123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;#include&lt;vector&gt;void test01()&#123; vector&lt;vector&lt;int&gt;&gt; v; vector&lt;int&gt; v1; vector&lt;int&gt; v2; vector&lt;int&gt; v3; vector&lt;int&gt; v4; vector&lt;int&gt; v5; for (int i = 0; i &lt; 5; i++) &#123; v1.push_back(i + 1); v2.push_back(i + 2); v3.push_back(i + 3); v4.push_back(i + 4); v5.push_back(i + 5); &#125; v.push_back(v1); v.push_back(v2); v.push_back(v3); v.push_back(v4); v.push_back(v5); for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; for (vector&lt;int&gt;::iterator vit = it-&gt;begin(); vit != it-&gt;end(); vit++) &#123; cout &lt;&lt; *vit &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125;&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++05_类模板和函数模板","date":"2020-08-05T23:29:56.000Z","path":"2020/08/06/C-05-类模板和函数模板/","text":"模板 C++提供两种模板：函数模板和类模板 函数模板函数模板的作用：建立一个通用的函数，而函数的返回值类型和形参类型不做具体的制定。 基本语法12template&lt;typename T&gt;函数的声明或者定义 其中的T就是通用的数据类型 1234567891011121314151617181920212223242526272829//函数模板template&lt;typename T&gt;//定义函数模板void Swap(T &amp;a, T &amp;b)&#123; T temp = a; a = b; b = temp;&#125;void test()&#123; int a = 20; int b = 30; double c = 1.1; double d = 2.2; //由编译器自己推导数据类型 Swap(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; //告诉编译器数据类型 Swap&lt;double&gt;(c, d); cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl;&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 注意事项 自动类型推导，必须推导出一致的数据类型才可以使用，例如上面的c，d就是一致的数据类型，如果换成b，c的话就会报错。 模板必须确定数据类型才可以使用 123456789101112131415161718192021222324252627282930313233343536//1、推导出的函数类型必须一致template&lt;typename T&gt;void swap(T &amp;a, T &amp;b)&#123; T temp = a; a = b; b = temp;&#125;void test01()&#123; int a = 10; int b = 20; char c = &#x27;c&#x27;; //std::swap(a,c);//报错 std::swap(a, b);// cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;//2、必须确定数据类型才可以使用模板template&lt;typename T&gt;void func()&#123; cout &lt;&lt; &quot;func函数数的调用!&quot; &lt;&lt; endl;&#125;void test02()&#123; //func();//报错 func&lt;int&gt;();//确定了数据类型&#125;int main()&#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 具体案例：数组模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354template&lt;typename T&gt;void Swap(T &amp;a,T &amp;b)&#123; T temp = a; a = b; b = temp;&#125;template&lt;typename T&gt;void Sort(T arr[], int a)&#123; for (int i = 0; i &lt; a; i++) &#123; for (int j = 0; j &lt; a - i - 1; j++) &#123; if (arr[j]&lt;arr[j + 1]) &#123; Swap(arr[j], arr[j + 1]); &#125; &#125; &#125;&#125;template&lt;typename T&gt;void printarray(T arr[],int a)&#123; for (int i = 0; i &lt; a; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl;&#125;void test()&#123; char chararray[] = &quot;abcdefg&quot;; //cout &lt;&lt; sizeof(chararray) &lt;&lt; endl; int num = sizeof(chararray) / sizeof(char); Sort(chararray, num); printarray(chararray, num);&#125;void test01()&#123; int intarray[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; int num = sizeof(intarray) / sizeof(int); //cout &lt;&lt; sizeof(intarray)&lt;&lt;endl; Sort(intarray, num); printarray(intarray, num);&#125;int main()&#123; test(); test01(); system(&quot;pause&quot;); return 0;&#125; 普通函数和函数模板的区别 普通函数调用时可以自动发生类型转化 模板函数调用时如果利用自动类型推导（也就是不告诉模板函数具体的数据类型}，不会发生隐式类型转换 如果利用显示指定类型的方式（告诉模板函数数据类型），那么也可以发生隐式类型转换 1234567891011121314151617181920212223242526//普通函数int myAdd(int a,int b)&#123; return a + b;&#125;//模板函数template&lt;typename T&gt;T myAdd02(T a, T b)&#123; return a + b;&#125;void test()&#123; int a = 10; int b = 20; char c = &#x27;c&#x27;; cout &lt;&lt; myAdd(a, c) &lt;&lt; endl;//普通函数调用时可以自动发生类型转换 //cout &lt;&lt; myAdd02(a, c) &lt;&lt; endl;//没有告诉模板函数具体数据类型，不能发生类型转换，报错 cout &lt;&lt; myAdd02&lt;int&gt;(a, c) &lt;&lt; endl;//告诉模板函数具体数据类型，数据转化为整型&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 普通函数和模板函数的调用规则 如果普通函数和模板函数都可以实现，优先调用普通函数 可以通过空模板参数列表强制调用模板函数 模板函数也可以发生重载 如果模板函数有更好地匹配，优先调用模板函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//1、普通函数和类函数都可以调用时调用普通函数void myPrint(int a, int b)&#123; cout &lt;&lt; &quot;调用的是普通函数！&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a,T b)&#123; cout &lt;&lt; &quot;调用的是类函数！&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b,T c)&#123; cout &lt;&lt; &quot;调用的是重载类函数！&quot; &lt;&lt; endl;&#125;void test01()&#123; int a = 10; int b = 20; myPrint(a, b);&#125;//2、通过空模板参数列表，强制调用模板函数void test02()&#123; int a = 10; int b = 20; //myPrint(a, b); myPrint&lt;&gt;(a, b);&#125;//3、函数模板也可以发生函数重载void test03()&#123; int a = 10; int b = 20; myPrint(a, b, 100);&#125;//4、如果函数模板产生更好地匹配，优先调用函数模板void test04()&#123; char c1=&#x27;a&#x27;; char c2=&#x27;b&#x27;; myPrint(c1, c2);&#125;int main()&#123; //test01(); //test02(); //test03(); test04(); system(&quot;pause&quot;); return 0;&#125; 模板的局限性：无法运行一些自定义的数据类型，但是可以用模板重载来解决问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//模板的局限性//模板并不是万能的，有些特定的数据类型，需要用具体化方式做特殊实现class person&#123;public: person(int age,string name) &#123; m_age = age; m_name = name; &#125; int m_age; string m_name;&#125;;template&lt;class T&gt;bool myCompare(T &amp;a, T &amp;b)&#123; if (a == b) &#123; return true; &#125; else &#123; return false; &#125;&#125;//利用具体化person版本实现代码，具体化优先调用template&lt;&gt;bool myCompare(person &amp;a, person &amp;b)&#123; if (a.m_age == b.m_age&amp;&amp;a.m_name == b.m_name) &#123; return true; &#125; else &#123; return false; &#125;&#125;void test01()&#123; int a = 10; int b = 20; bool ret = myCompare(a, b); if (ret) &#123; cout &lt;&lt; &quot;a==b&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;a!=b&quot; &lt;&lt; endl; &#125;&#125;void test02()&#123; person p1(23, &quot;Tom&quot;); person p2(13, &quot;Tom&quot;); bool ret=myCompare(p1, p2); if (ret) &#123; cout &lt;&lt; &quot;a==b&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;a!=b&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; test02(); system(&quot;pause&quot;); return 0;&#125; 类模板类模板的作用建立一个通用的类，类中的数据类型可以不具体制定 类模板的基本语法12template&lt;class T&gt;类 12345678910111213141516171819202122232425262728template&lt;class TypeName,class TypeAge&gt;class person&#123;public: person(TypeName name,TypeAge age) &#123; this-&gt;m_name = name; this-&gt;m_age = age; &#125; void showperson() &#123; cout &lt;&lt; &quot;name : &quot; &lt;&lt; this-&gt;m_name &lt;&lt; endl; cout &lt;&lt; &quot;age : &quot; &lt;&lt; this-&gt;m_age &lt;&lt; endl; &#125; TypeName m_name; TypeAge m_age;&#125;;void test01()&#123; person&lt;string, int&gt; p1(&quot;孙悟空&quot;,999);//必须初始化，否则报错 p1.showperson();&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 类模板和函数模板的区别 类模板中没有自动类型推导的使用方式 类模板在模板参数列表中可以有默认参数 123456789101112131415161718192021222324252627282930313233343536template&lt;class TypeName,class TypeAge = int &gt;//默认第二个数据类型为intclass person&#123;public: person(TypeName name,TypeAge age) &#123; this-&gt;m_name = name; this-&gt;m_age = age; &#125; void showperson() &#123; cout &lt;&lt; &quot;name : &quot; &lt;&lt; this-&gt;m_name &lt;&lt; endl; cout &lt;&lt; &quot;age : &quot; &lt;&lt; this-&gt;m_age &lt;&lt; endl; &#125; TypeName m_name; TypeAge m_age;&#125;;void test01()&#123; //person p(&quot;孙悟空&quot;,1000);//错误,类模板使用时候，不可以用自动类型推导 person&lt;string, int&gt; p1(&quot;孙悟空&quot;,999);//必须初始化，否则报错 p1.showperson();&#125;//类模板中的参数列表可以有默认参数void test02()&#123; person&lt;string&gt; p2(&quot;猪八戒&quot;, 999); p2.showperson();&#125;int main()&#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 类模板中成员函数的创建时机 普通类的成员函数一开始就可以创建 类模板中 的成员函数在调用类的时候才开始创建 1234567891011121314151617181920212223242526272829303132333435363738394041424344class person01&#123;public: void showperson01() &#123; cout &lt;&lt; &quot;正在调用showperson01&quot; &lt;&lt; endl; &#125;&#125;;class person02&#123;public: void showperson02() &#123; cout &lt;&lt; &quot;正在调用showperson02&quot; &lt;&lt; endl; &#125;&#125;;//类模板的成员函数不会一开始就创建，要调用的时候才创建template&lt;class T&gt;class Myclass&#123;public: T obj; void func1() &#123; obj.showperson01(); &#125; void func2() &#123; obj.showperson02(); &#125;&#125;;void test()&#123; Myclass&lt;person02&gt; p; //p.func1();//报错，因为上面的类模板没有创建person1这种类 p.func2();&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 类模板对象做函数参数一共有三种传入方式： 指定传入的类型：直接显示对象的数据类型（最常用） 参数模板化：将对象中的参数化为模板进行传递 整个类模板化：将这个对象类型模板化进行传递 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//类模板做函数参数template&lt;class T1,class T2 &gt;class person&#123;public: person(T1 name,T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; void showperson() &#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; endl; cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl; &#125; T1 m_Name; T2 m_Age;&#125;;//1、指定方式传入void printperson01(person&lt;string, int&gt;&amp;p1)&#123; p1.showperson();&#125;void test01()&#123; person&lt;string, int&gt;p1(&quot;孙悟空&quot;, 1000); printperson01(p1);&#125;//2、参数模板化template&lt;class T1,class T2&gt;void printperson02(person&lt;T1,T2&gt;&amp;p2)&#123; p2.showperson();&#125;void test02()&#123; person&lt;string, int&gt;p2(&quot;猪八戒&quot;, 900); printperson02(p2);&#125;//3、整个类模板化template&lt;class T&gt;void printperson03(T &amp;p3)&#123; p3.showperson();&#125;void test03()&#123; person&lt;string, int&gt;p3(&quot;唐僧&quot;, 10000); printperson03(p3);&#125;int main()&#123; //test01(); //test02(); test03(); system(&quot;pause&quot;); return 0;&#125; 类模板与继承注意点： 当子类要继承一个父类是类模板时，子类在声明的时候，要具体指出父类中T的类型 如果不指定，编译器就无法给子类分配内存 如果想灵活指定父类的T的类型，子类也需变为类模板 123456789101112131415161718192021222324252627282930313233343536373839404142//必须知道父类T的类型才能继承给子类template&lt;class T&gt;class Base&#123;public: T m;&#125;;//class Son :public Base//错误class Son1:public Base&lt;int&gt;//正确&#123;&#125;;void test()&#123; Son1 s;&#125;//如果想灵活指定父类中的数据类型，子类也用类模板template&lt;class T1,class T2&gt;class Son2 :public Base&lt;T2&gt;&#123;public: Son2() &#123; cout &lt;&lt; &quot;T1的数据类型为：&quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; &quot;T2的数据类型为：&quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl; &#125; T1 m;&#125;;void test01()&#123; Son2&lt;int, char&gt;s2;&#125;int main()&#123; //test(); test01(); system(&quot;pause&quot;); return 0;&#125; 类模板成员函数类外实现类模板中的成员函数类外实现是，想需要加上模板参数列表 123456789101112131415161718192021222324252627282930313233343536373839//类模板成员函数类外实现template&lt;class T1,class T2&gt;class person&#123;public: person(T1 name, T2 age); //&#123; // m_Name = name; // m_Age = age; //&#125; void showperson(); //&#123; // cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;年龄：&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl; //&#125; T1 m_Name; T2 m_Age;&#125;;template&lt;class T1,class T2&gt;person&lt;T1, T2 &gt;::person(T1 name, T2 age)//构造函数&#123; m_Name = name; m_Age = age;&#125;template&lt;class T1,class T2&gt;void person&lt;T1, T2&gt;::showperson()&#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;年龄：&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;void test01()&#123; person&lt;string, int&gt; p(&quot;Tom &quot;,18); p.showperson();&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 类模板文件编写问题： 类模板中的成员函数是在调用的时候才创建，导致分文件编写的时候链接不到 解决方法： 将声明和实现都写在同一个文件中，并更改后缀名为hpp 12345678910111213141516171819202122232425#pragma once#include&lt;iostream&gt;using namespace std;#include&lt;string&gt;template&lt;class T1, class T2&gt;class person&#123;public: person(T1 name, T2 age); void showperson(); T1 m_Name; T2 m_Age;&#125;;template&lt;class T1, class T2&gt;person&lt;T1, T2 &gt;::person(T1 name, T2 age)&#123; m_Name = name; m_Age = age;&#125;template&lt;class T1, class T2&gt;void person&lt;T1, T2&gt;::showperson()&#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;年龄：&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125; 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;#include&quot;person.hpp&quot;//分文件编写//template&lt;class T1,class T2&gt;//class person//&#123;//public:// person(T1 name, T2 age);// void showperson();// T1 m_Name;// T2 m_Age;////&#125;;//template&lt;class T1,class T2&gt;//person&lt;T1, T2 &gt;::person(T1 name, T2 age)//&#123;// m_Name = name;// m_Age = age;//&#125;//template&lt;class T1,class T2&gt;//void person&lt;T1, T2&gt;::showperson()//&#123;// cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;年龄：&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;//&#125;void test01()&#123; person&lt;string, int&gt; p(&quot;Tom &quot;,18); p.showperson();&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 类模板和友元全局函数类内实现：直接在类内声明友元即可 全局函数类外实现：比较麻烦需要提前让编译器知道全局函数和类的存在 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//类模板成员函数类外实现template&lt;class T1,class T2&gt;class person;template&lt;class T1,class T2&gt;void showperson02(person&lt;T1, T2&gt;p)//这是全局函数，不用加作用域&#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.m_Name &lt;&lt; &quot;年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;template&lt;class T1,class T2&gt;class person&#123; //1、类内实现 friend void showperson01(person&lt;T1, T2&gt;p) &#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.m_Name &lt;&lt; &quot;年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl; &#125; //2、类外实现 friend void showperson02(person&lt;T1, T2&gt;p);public: person(T1 name, T2 age) &#123; m_Name = name; m_Age = age; &#125;private: T1 m_Name; T2 m_Age;&#125;;void test01()&#123; person&lt;string, int&gt; p(&quot;Tom &quot;,18); showperson01(p);&#125;void test02()&#123; person&lt;string, int&gt; p(&quot;Jerry &quot;, 20); showperson01(p);&#125;int main()&#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 类模板案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#pragma once#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;class Myarray&#123;public: //构造函数 Myarray(int capacity) &#123; this-&gt;m_capacity = capacity; this-&gt;m_size = 0; this-&gt;m_Address = new T[this-&gt;m_capacity]; //cout &lt;&lt; &quot;构造函数的调用！&quot; &lt;&lt; endl; &#125; //析构函数 ~Myarray() &#123; if (this-&gt;m_Address != NULL) &#123; delete[]this-&gt;m_Address; this-&gt;m_Address = NULL; &#125; //cout &lt;&lt; &quot;析构函数的调用！&quot; &lt;&lt; endl; &#125; //拷贝构造 Myarray(const Myarray&amp; arr) &#123; this-&gt;m_capacity = arr.m_capacity; this-&gt;m_size = arr.m_size; this-&gt;m_Address = new T[this-&gt;m_capacity]; for (int i = 0; i &lt; this-&gt;m_size; i++) &#123; this-&gt;m_Address[i] = arr.m_Address[i]; &#125; //cout &lt;&lt; &quot;拷贝构造函数的调用！&quot; &lt;&lt; endl; &#125; //operator =重载 Myarray&amp; operator=(const Myarray&amp; arr) &#123; //先判断原来堆区数据是否为空 if (this-&gt;m_Address != NULL) &#123; delete[]this-&gt;m_Address; this-&gt;m_Address = NULL; this-&gt;m_capacity = 0; this-&gt;m_size = 0; &#125; this-&gt;m_capacity = arr.m_capacity; this-&gt;m_size = arr.m_size; this-&gt;m_Address = new T[this-&gt;m_capacity]; for (int i = 0; i &lt; this-&gt;m_size; i++) &#123; this-&gt;m_Address[i] = arr.m_Address[i]; &#125; //cout &lt;&lt; &quot;重载=函数的调用！&quot; &lt;&lt; endl; return *this; &#125; //尾插法 void Push_Back(const T &amp;val) &#123; if (this-&gt;m_size == this-&gt;m_capacity) &#123; return; &#125; this-&gt;m_Address[this-&gt;m_size] = val; this-&gt;m_size++; &#125; //尾删法 void Pop_Back() &#123; if (this-&gt;m_size == 0) &#123; return; &#125; this-&gt;m_size--; &#125; //[]下标重载 T&amp; operator[](int index) &#123; return this-&gt;m_Address[index]; &#125; //访问数组容量 int getCapacity() &#123; return this-&gt;m_capacity; &#125; //访问数组大小 int getSize() &#123; return this-&gt;m_size; &#125;private: T* m_Address; int m_capacity;//数组大小 int m_size;//数组个数&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;using namespace std;#include&quot;Myarray.hpp&quot;#include&lt;string&gt;void print_arr(Myarray &lt;int&gt; &amp;arr)&#123; for (int i = 0; i &lt; arr.getSize(); i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; cout &lt;&lt; &quot;数组的大小为&quot; &lt;&lt; arr.getSize() &lt;&lt; endl; cout &lt;&lt; &quot;数组的容量为&quot; &lt;&lt; arr.getCapacity()&lt;&lt; endl;&#125;void test01()&#123; Myarray &lt;int&gt;arr(5); for (int i = 0; i &lt; 3; i++) &#123; arr.Push_Back(i); &#125; print_arr(arr); arr.Pop_Back(); print_arr(arr);&#125;//自定义数据class person&#123;public: person()&#123;&#125;; #if 0 为什么需要默认构造函数？ 主要是因为建立数组时，Myarray&lt;person&gt; arr2(10），无参数可传， 无法调用有参构造函数，但是一旦我们手动创建了有参构造函数，那么 编译器就不会再为我们创建一个默认构造函数。 #endif person(int age,string name) &#123; this-&gt;m_age = age; this-&gt;m_name = name; &#125; int m_age; string m_name;&#125;;void print_person_arr(Myarray&lt;person&gt; &amp;arr)&#123; cout &lt;&lt; &quot;姓名\\t年龄\\t&quot; &lt;&lt; endl; for (int i = 0; i &lt; arr.getSize(); i++) &#123; cout &lt;&lt; arr[i].m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; arr[i].m_age &lt;&lt; &quot;\\t&quot; &lt;&lt; endl; &#125; cout &lt;&lt; &quot;数组的容量为：&quot; &lt;&lt; arr.getCapacity() &lt;&lt; endl; cout &lt;&lt; &quot;数组的大小为：&quot; &lt;&lt; arr.getSize() &lt;&lt; endl; cout &lt;&lt; &quot;-----------------------------------&quot; &lt;&lt; endl;&#125;void test02()&#123; Myarray&lt;person&gt; arr2(10); person p1(18,&quot;张飞&quot;); person p2(19, &quot;关羽&quot;); person p3(20, &quot;刘备&quot;); person p4(21, &quot;赵云&quot;); person p5(22, &quot;诸葛亮&quot;); //尾插法插到数组末尾 arr2.Push_Back(p1); arr2.Push_Back(p2); arr2.Push_Back(p3); arr2.Push_Back(p4); arr2.Push_Back(p5); //打印数组 print_person_arr(arr2);&#125;int main()&#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++04_文件读写","date":"2020-07-18T07:31:57.000Z","path":"2020/07/18/C-04-文件读写/","text":"文件读写","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++03_类和对象","date":"2020-07-16T23:20:55.000Z","path":"2020/07/17/C-03-类和对象/","text":"万物皆对象 1、封装 封装的意义 在设计类的时候，将属性和行为写在一起，用来表现生活的事物。 在设计类的时候，把属性和行为放在不同的权限下，加以控制。 struct和class的区别 C++中struct和class唯一的区别在于默认的访问权限，struct的默认权限为公共，class的默认权限为私有。 成员属性私有化 我们一般把成员属性设置为私有权限，把成员函数设置为公共权限，然后我们可以调用成员函数来对成员属性进行读写操作，这样做的优点如下： 我们可以自己控制读写成员属性的权限。 我们可以检测写入数据的有效性，可以把写入的数据限制在一个范围内。 2、对象的初始化和清理 构造函数和析构函数 一个对象如果没有初始状态，那么使用后果是未知的；如果一个对象在使用完后没有及时销毁数据，那么会有一些安全隐患。而C++中的构造函数和析构函数就是用来解决上述问题，构造函数可以对对象进行初始化，析构函数可以对对象进行清理。当然如果我们没有手动添加构造函数，编译器也会提供构造函数和析构函数，只不过编译器提供的构造函数和析构函数是空实现。 构造函数：主要作用是在创建对象时为对象的成员属性赋初值，构造函数由编译器自动调用，无需手动调用。基本语法：类名(){},构造函数可以有参数，因此可以发生重载。 析构函数：主要作用是销毁对象，执行一些清理工作，构造函数由系统自动调用，无需手动调用。基本语法：~类名(){}，析构函数不可以有参数，因此不可以发生重载。 拷贝构造函数的调用时机 使用一个创建完毕的对象来初始化一个新对象，例如 123person p(100);person p1(p);person p2=p; 值传递的方式给函数参数传值 123456void dowork(person p1);void test()&#123; person p(20); dowork(p);&#125; 以值的方式返回局部对象,例如 123456789person dowork2()&#123; person p1(30); return p1;&#125;void test01()&#123; person p=dowork2();&#125; 拷贝构造函数的调用规则 如果用户提供有参构造函数，那么系统不会自动提供默认无参构造函数，但是会提供默认拷贝构造函数 如果用户提供拷贝构造函数，那么系统不会自动提供默认无参构造函数，也不会提供默认有参构造函数 深拷贝与浅拷贝 浅拷贝：浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。例如： 12345678910111213141516171819202122232425class person&#123;public: int m_age; int *Height; person(int age,int height) &#123; Height= new int(height); m_age = age; &#125; person(const person &amp;p) &#123; m_age = p.m_age; //浅拷贝操作 Height = p.Height;//函数默认的就是调用这行函数 &#125; ~person() &#123; if (Height != NULL) &#123; delete Height; Height = NULL;//重复删除了 &#125; &#125;&#125;; 深拷贝：深拷贝指的就是当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值。例如： 1234567891011121314151617181920212223242526class person&#123;public: int m_age; int *Height; person(int age,int height) &#123; Height= new int(height); m_age = age; &#125; person(const person &amp;p) &#123; m_age = p.m_age; //深拷贝操作 //Height = new int(*p.Height); //不会出现交叉重复删除的毛病，因为另外在堆区开辟了一块空间 &#125; ~person() &#123; if (Height != NULL) &#123; delete Height; Height = NULL;//没有重复删除 &#125; &#125;&#125;; 初始化列表 传统方式 123456Person(int a, int b, int c) &#123; m_A = a; m_B = b; m_C = c;&#125; 初始化列表方式 1Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125; 类对象作为类成员 类中的成员可以是另一个类的对象，我们称该成员为 对象成员，例如： 12345class A &#123;&#125;class B&#123; A a；&#125; 先构造A再构造B，先析构B再析构A 静态成员 静态成员就是在成员变量和成员函数前面加上关键字static，分为静态成员变量和静态成员函数 静态成员变量: 所有对象共享一份数据 在编译阶段分配内存 类内声明，类外初始化 静态成员函数： 所有对象共享一个函数 静态成员函数只能访问静态成员变量 注意点： 空对象占一个字节，用于存储地址 非静态成员变量占对象空间 静态成员对象、静态成员函数、非静态成员函数不占用对象空间 3、this指针和常函数 this指针 this指针是隐含在每一个非静态成员函数内的一种指针，this指针的指向被调用的成员函数所属的对象，this指针不需要定义，直接使用即可。 this指针的用途： 当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，使用return *this; 空指针访问成员函数 123456void test()&#123; person *p=NULL; p-&gt;func1();//空指针可以调用成员函数 p-&gt;func2();//如果成员函数中使用到this指针，那么会报错&#125; 常函数和常对象 常函数： 成员函数后，也就是()后{}前加const，这种函数被称为常函数。 常函数内不可以修改成员属性 成员属性前加关键字mutable后，在常函数中依然可以修改 常对象： 声明对象前加const称该对象为常对象 常对象只能调用常函数 4、友元友元的目的是想让一个函数或者类来访问另一个类的私有成员，友元关键字为friend 全局函数做友元 1234567891011121314151617181920212223class person&#123; friend void gay(person *person)public: person() &#123; this-&gt;m_age=20; this-&gt;m_password=1999; &#125; int m_age;private: int m_password;&#125;void gay(person *person)&#123; cout&lt;&lt;&quot;年龄为：&quot;&lt;&lt;person-&gt;m_age&lt;&lt;endl; cout&lt;&lt;&quot;密码为：&quot;&lt;&lt;person-&gt;m_passage&lt;&lt;endl;&#125;void test()&#123; person p; gay(&amp;p);&#125; 类做友元 1234567891011121314151617181920212223242526272829303132333435363738class person;class gay&#123;public: gay(); void output();private: person *p;&#125;class person&#123; friend class gay;public: person()public: int m_age;private: int m_password;&#125;person::person()&#123; this-&gt;m_age=20; this-&gt;m_password=1999;&#125;gay::gay()&#123; p=new person;&#125;void gay::output()&#123; cout&lt;&lt;&quot;年龄为：&quot;&lt;&lt;person-&gt;m_age&lt;&lt;endl; cout&lt;&lt;&quot;密码为：&quot;&lt;&lt;person-&gt;m_passage&lt;&lt;endl;&#125;void test()&#123; gay g; g.output();&#125; 成员函数做友元 1234567891011121314151617181920212223242526272829303132333435363738394041424344class person;class gay&#123;public: gay(); void output1(); void output2();private: person *p;&#125;class person&#123; friend void gay::output2();public: person()public: int m_age;private: int m_password;&#125;person::person()&#123; this-&gt;m_age=20; this-&gt;m_password=1999;&#125;gay::gay()&#123; p=new person;&#125;void gay::output1()&#123; cout&lt;&lt;&quot;年龄为：&quot;&lt;&lt;person-&gt;m_age&lt;&lt;endl;&#125;void gay::output2()&#123; cout&lt;&lt;&quot;年龄为：&quot;&lt;&lt;person-&gt;m_age&lt;&lt;endl; cout&lt;&lt;&quot;密码为：&quot;&lt;&lt;person-&gt;m_passage&lt;&lt;endl;&#125;void test()&#123; gay g; g.output1(); g.output2();&#125; 5、运算符重载运算符重载：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。 加号运算符重载 123456789101112131415161718192021222324252627282930313233class Person &#123;public: Person() &#123;&#125;; Person(int a, int b) &#123; this-&gt;m_A = a; this-&gt;m_B = b; &#125; //成员函数实现 + 号运算符重载 Person operator+(const Person&amp; p) &#123; Person temp; temp.m_A = this-&gt;m_A + p.m_A; temp.m_B = this-&gt;m_B + p.m_B; return temp; &#125;public: int m_A; int m_B;&#125;;//全局函数实现 + 号运算符重载//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;// Person temp(0, 0);// temp.m_A = p1.m_A + p2.m_A;// temp.m_B = p1.m_B + p2.m_B;// return temp;//&#125;void test()&#123; Person p1(10,30); Person p2(20,30); Person p3=p1+p2;&#125; 左移运算符重载 1234567891011121314151617181920212223242526//只能用全局函数实现class person&#123; friend ostream&amp; operator&lt;&lt;(ostream &amp;cout, person &amp;p);public: person(int a, int b) &#123; m_a = a; m_b = b; &#125;private: int m_a; int m_b;&#125;;//引用是因为返回引用有利于链式输出ostream&amp; operator&lt;&lt;(ostream &amp;cout, person &amp;p)&#123; cout &lt;&lt; &quot;m_a = &quot; &lt;&lt; p.m_a &lt;&lt;endl; cout &lt;&lt; &quot;m_b = &quot; &lt;&lt; p.m_b &lt;&lt; endl; return cout;&#125;void test()&#123; person p(20,50); cout &lt;&lt; p &lt;&lt;&quot;helloworld&quot;&lt;&lt; endl;&#125; 递增运算符重载 1234567891011121314151617181920212223242526272829303132333435363738394041class person&#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, person&amp; mynum);public: person() &#123; m_num = 0; &#125; //前置++，返回引用 person&amp; operator++() &#123; ++m_num; return *this; &#125; //后置++，返回值 person operator++(int) &#123; person temp = *this; this-&gt;m_num++; return temp; &#125;private: int m_num;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; cout, person&amp; mynum)&#123; cout &lt;&lt; &quot;m_num = &quot; &lt;&lt; mynum.m_num &lt;&lt; endl; return cout;&#125;void test()&#123; person mynum; cout &lt;&lt; mynum++ &lt;&lt; endl; cout &lt;&lt; mynum &lt;&lt; endl;&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 赋值运算符重载 123456789101112131415161718192021222324252627282930313233343536373839404142class Person&#123;public: Person(int age) &#123; //将年龄数据开辟到堆区 m_Age = new int(age); &#125; //重载赋值运算符 Person&amp; operator=(Person &amp;p) &#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; //编译器提供的代码是浅拷贝 //m_Age = p.m_Age; //提供深拷贝 解决浅拷贝的问题 m_Age = new int(*p.m_Age); //返回自身 return *this; &#125; ~Person() &#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; &#125; //年龄的指针 int *m_Age;&#125;;void test01()&#123; Person p1(18); Person p2(20); Person p3(30); p3 = p2 = p1; //赋值操作&#125; 关系运算符重载 123456789101112131415161718192021222324252627282930313233class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125;; bool operator==(Person &amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return true; &#125; else &#123; return false; &#125; &#125; bool operator!=(Person &amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return false; &#125; else &#123; return true; &#125; &#125; string m_Name; int m_Age;&#125;; 6、继承 继承的基本语法1class A : public B; A类称为子类或者派生类 B类称为父类或者基类 优点：从基类继承过来的表现其共同的部分，而新增的成员表现其独特的部分 基本属性 可以访问 不可访问 公共属性 该类的函数、子类函数、友元函数，该类的对象 无 保护属性 该类的函数、子类函数、友元函数 该类的对象 私有属性 该类函数、友元函数 子类的函数、该类的对象 继承方式 基类 继承方式 公共属性 保护属性 私有属性 子类1 公共继承 公共属性 保护属性 不可用 子类2 保护继承 保护属性 保护属性 不可用 子类3 私有继承 私有属性 私有属性 不可用 继承同名成员函数处理方式 访问子类同名成员，直接访问即可 访问父类同名函数，需要加作用域 子类对象可以直接访问到子类中同名成员 子类对象加作用域可以访问到父类同名成员 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数 继承同名成员函数处理方式静态成员和非静态成员出现同名，处理方式一致 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 有两种访问的方式（通过对象 和 通过类名） 多继承一个子类可以继承多个父类 语法：class 子类 : 继承方式 父类1 , 继承方式 父类2…… 多继承可能会引发父类中有同名成员出现，需要加作用域区分 菱形继承两个派生类继承同一个基类，同时又有某个类同时继承者两个派生类 这种继承方式被称为菱形继承。 菱形继承的问题： 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义 利用虚继承可以解决菱形继承问题 12345678910111213141516171819202122232425262728293031class Animal&#123;public: int m_age;&#125;;class Tiger:virtual public Animal&#123;public: &#125;;class Lion:virtual public Animal&#123;public: &#125;;//菱形继承class TigerLion:public Tiger,public Lion&#123;public: &#125;;void test()&#123; TigerLion TL; TL.Tiger::m_age = 100; TL.Lion::m_age = 200; cout &lt;&lt; &quot;TL.age = &quot; &lt;&lt; TL.Tiger::m_age &lt;&lt; endl; cout &lt;&lt; &quot;TL.age = &quot; &lt;&lt; TL.Lion::m_age &lt;&lt; endl; cout &lt;&lt; &quot;TL.age = &quot; &lt;&lt; TL.m_age &lt;&lt; endl;//200,因为是同一份数据&#125; 7、多态 多态的基本概念 什么是多态？ 多态可以认为就是同一语句有多种不同的表现状态 多态分为两类 静态多态：函数重载和运算符重载属于静态多态 动态多态：派生类和虚函数属于动态多态 静态多态和动态多态的区别 静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址 多态满足条件 有继承关系 子类重写父类中的虚函数 多态使用条件 父类指针或引用指向子类对象 重写：函数返回值类型 函数名 参数列表 完全一致称为重写 多态的实现原理 当类中声明虚函数时，编译器会在类中生成一个虚函数表 虚函数表是一个存储类成员函数指针的数据结构 一个虚函数表只属于一个类 虚函数表是由编译器自动生成与维护的 virtual成员函数会被编译器放入虚函数表中 存在虚函数时，每个对象中都有一个指向虚函数表的指针(vptr*指针） 12345678910111213141516171819202122232425262728293031323334353637class Animal&#123;public: virtual void speak()//父类纯虚函数 &#123; cout &lt;&lt; &quot;动物在说话！&quot; &lt;&lt; endl; &#125;&#125;;class Cat:public Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;小猫在说话！&quot; &lt;&lt; endl; &#125;&#125;;class Dog :public Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;小狗在说话！&quot; &lt;&lt; endl; &#125;&#125;;void Dospeak(Animal &amp;animal)&#123; animal.speak();&#125;void test()&#123; Cat cat; Dospeak(cat); Dog dog; Dospeak(dog);&#125; 多态的优点优点如下 代码组织结构清晰 可读性强 利于前期和后期的扩展以及维护 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Num&#123;public: virtual int getresult()//纯虚函数 &#123; return 0; &#125; int m_a; int m_b;&#125;;class Add :public Num&#123;public: int getresult() &#123; return m_a + m_b; &#125;&#125;;class Sub :public Num&#123;public: int getresult() &#123; return m_a - m_b; &#125;&#125;;class Mul :public Num&#123;public: int getresult() &#123; return m_a * m_b; &#125;&#125;;void test02()&#123; Num *num=new Add; num-&gt;m_a = 100; num-&gt;m_b = 100; cout &lt;&lt; num-&gt;m_a &lt;&lt; &quot;+&quot; &lt;&lt; num-&gt;m_b &lt;&lt; &quot; = &quot; &lt;&lt; num-&gt;getresult() &lt;&lt; endl; delete num; Num *num1 = new Sub; num1-&gt;m_a = 100; num1-&gt;m_b = 100; cout &lt;&lt; num1-&gt;m_a &lt;&lt; &quot;-&quot; &lt;&lt; num1-&gt;m_b &lt;&lt; &quot; = &quot; &lt;&lt; num1-&gt;getresult() &lt;&lt; endl; delete num1; Num *num2 = new Mul; num2-&gt;m_a = 100; num2-&gt;m_b = 100; cout &lt;&lt; num2-&gt;m_a &lt;&lt; &quot;*&quot; &lt;&lt; num2-&gt;m_b &lt;&lt; &quot; = &quot; &lt;&lt; num2-&gt;getresult() &lt;&lt; endl; delete num2;&#125; 纯虚函数和抽象类 基本语法：virtual 返回值类型 函数名 (参数列表) = 0 抽象类：当类中有了纯虚函数，这个类也称为抽象类 抽象类特点： 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class AbstractDrinking&#123;public: virtual void Boil() = 0; virtual void Put() = 0; virtual void Pour() = 0; virtual void Add() = 0;&#125;;class Coffee:public AbstractDrinking&#123;public: virtual void Boil() &#123; cout &lt;&lt; &quot;1、煮农夫山泉&quot; &lt;&lt; endl; &#125; virtual void Put() &#123; cout &lt;&lt; &quot;2、倒咖啡&quot; &lt;&lt; endl; &#125; virtual void Pour() &#123; cout &lt;&lt; &quot;3、冲咖啡&quot; &lt;&lt; endl; &#125; virtual void Add() &#123; cout &lt;&lt; &quot;4、加糖和牛奶&quot; &lt;&lt; endl; &#125;&#125;;class Tea :public AbstractDrinking&#123;public: virtual void Boil() &#123; cout &lt;&lt; &quot;1、煮矿泉水&quot; &lt;&lt; endl; &#125; virtual void Put() &#123; cout &lt;&lt; &quot;2、倒茶叶&quot; &lt;&lt; endl; &#125; virtual void Pour() &#123; cout &lt;&lt; &quot;3、冲茶叶&quot; &lt;&lt; endl; &#125; virtual void Add() &#123; cout &lt;&lt; &quot;4、加柠檬片&quot; &lt;&lt; endl; &#125;&#125;;void dowork(AbstractDrinking *abs)&#123; abs-&gt;Boil(); abs-&gt;Put(); abs-&gt;Pour(); abs-&gt;Add(); delete abs; cout &lt;&lt; &quot;------------------&quot; &lt;&lt; endl;&#125;void test()&#123; dowork(new Coffee); dowork(new Tea);&#125; 虚析构和纯虚析构 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码，解决方式：将父类中的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构共性： 可以解决父类指针释放子类对象 都需要有具体的函数实现 虚析构和纯虚析构区别： 如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法：virtual ~类名(){} 纯虚析构语法：virtual ~类名()=0; ​ 类名::~类名(){}; 注意点： 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构 拥有纯虚析构函数的类也属于抽象类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Animal &#123;public: Animal() &#123; cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl; &#125; virtual void Speak() = 0; //析构函数加上virtual关键字，变成虚析构函数 //virtual ~Animal() //&#123; // cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl; //&#125; virtual ~Animal() = 0;&#125;;Animal::~Animal()&#123; cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;&#125;//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。class Cat : public Animal &#123;public: Cat(string name) &#123; cout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl; m_Name = new string(name); &#125; virtual void Speak() &#123; cout &lt;&lt; *m_Name &lt;&lt; &quot;小猫在说话!&quot; &lt;&lt; endl; &#125; ~Cat() &#123; cout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl; if (this-&gt;m_Name != NULL) &#123; delete m_Name; m_Name = NULL; &#125; &#125;public: string *m_Name;&#125;;void test01()&#123; Animal *animal = new Cat(&quot;Tom&quot;); animal-&gt;Speak(); //通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏 //怎么解决？给基类增加一个虚析构函数 //虚析构函数就是用来解决通过父类指针释放子类对象 delete animal;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100class CPU&#123;public: virtual void caculate()=0; virtual ~CPU() &#123; cout &lt;&lt; &quot;CPU的析构函数&quot; &lt;&lt; endl; &#125;&#125;;class VideoCard&#123;public: virtual void display()=0; virtual ~VideoCard() &#123; cout &lt;&lt; &quot;VideoCard的析构函数&quot; &lt;&lt; endl; &#125;&#125;;class Memory&#123;public: virtual void storage()=0; virtual ~Memory() &#123; cout &lt;&lt; &quot;Memory的析构函数&quot; &lt;&lt; endl; &#125;&#125;;class Computer&#123;public: Computer(CPU *cpu,VideoCard *vc,Memory *mem) &#123; m_cpu = cpu; m_vc = vc; m_mem = mem; &#125; ~Computer() &#123; if (m_cpu != NULL) &#123; delete m_cpu; m_cpu = NULL; &#125; if (m_vc != NULL) &#123; delete m_vc; m_vc = NULL; &#125; if (m_mem != NULL) &#123; delete m_mem; m_mem = NULL; &#125; cout &lt;&lt; &quot;Computer析构函数的调用！&quot; &lt;&lt; endl; &#125; void work() &#123; m_cpu-&gt;caculate(); m_vc-&gt;display(); m_mem-&gt;storage(); &#125;private: CPU *m_cpu; VideoCard *m_vc; Memory *m_mem;&#125;;class intelcpu :public CPU&#123;public: void virtual caculate() &#123; cout &lt;&lt; &quot;intel的CPU&quot; &lt;&lt; endl; &#125;&#125;;class intelvideocard :public VideoCard&#123;public: void virtual display() &#123; cout &lt;&lt; &quot;intel的显卡&quot; &lt;&lt; endl; &#125;&#125;;class intelmemory :public Memory&#123;public: void virtual storage() &#123; cout &lt;&lt; &quot;intel的内存条&quot; &lt;&lt; endl; &#125;&#125;;void test()&#123; CPU *icpu = new intelcpu ; VideoCard *ivideocard =new intelvideocard; Memory *imem=new intelmemory; cout &lt;&lt; &quot;第一台电脑：&quot; &lt;&lt; endl; Computer *icomputer = new Computer(icpu, ivideocard, imem); icomputer-&gt;work(); delete icomputer;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++02_引用","date":"2020-07-16T08:32:10.000Z","path":"2020/07/16/C-02-引用/","text":"引用 引用的作用： 给变量起别名，当修改别名的值时，变量的值也会发生改变 引用的基本语法 数据类型 &amp;别名 = 变量名 引用的注意事项 引用必须初始化 引用初始化后，就不可以改变，就是说引用后别名不能再指向其他变量 引用做函数返回值 引用可以作为函数的返回值，用法：返回值类型&amp; 函数名(形参) 注意不要返回局部变量的引用，因为局部变量存放在栈区，函数调用完后就会释放栈区的数据，但是可以返回静态局部变量 引用的本质是一个常量指针，也就是所指向的位置不能改变 常量引用 常量引用主要是用来修饰形参，防止误操作 形参列表中，加const修饰形参引用，防止形参引用修改原变量","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++01_内存分区模型和new关键字","date":"2020-07-16T08:05:40.000Z","path":"2020/07/16/C-01-内存分区模型和new关键字/","text":"内存分区模型 new关键字语法：new 数据类型 ​ delete 接收指针","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"基于Matlab的K-means算法图像切割","date":"2020-07-06T01:18:56.000Z","path":"2020/07/06/K-means算法/","text":"开始1、研究图像分割的背景及意义我们生活中很多照片都是包括两个部分：前景和背景。但是人们一般只会对前景感兴趣，所以我们需要一个工具把前景部分从图片中提取出来以便人们对其加以利用，而图片分割技术便是一个很好的工具，可以根据像素点的不同采用相对应的算法就可以完整地把前景部分提取出来。 2、图像分割采用的算法本文采用的算法是大名鼎鼎的K-means算法,也叫K均值算法，是一种动态聚类算法。 K-means算法简介K-means算法是一种迭代算法，通过反复修改聚类结果来进行优化，以达到最优的聚类结果。 K-means算法步骤(1 )选取k个样本点为初始聚类中心(2)使用最近邻规则将所有样本分配到各聚类中心所代表的k类中(3)计算各类的重心(均值向量)，并令该重心为新的聚类中心，因为在该步中要计算k个聚类中的样本均值，故称作k-均值算法(4)如果新的聚类中心与原聚类中心不一致，则表示尚未得到最佳聚类结果，返回步骤(2)，继续迭代计算;(5)如果新的聚类中心与原聚类中心一致，则迭代过程结束，此时的聚类结果就是最优聚类结果。 3、具体代码实现12345678910111213141516171819202122232425262728293031%%%%%%%%%%%%%%%%%%%%%代码部分%%%%%%%%%%%%%%%%%%%%%clcclearclose allI = imread(&#x27;C:/Users/USER LYT/Documents/MATLAB/模式识别/图片/海贼王1.jpg&#x27;); [M,N,L] = size(I);%构造样本空间A = reshape(I(:, :, 1), M*N, 1); % 将RGB分量各转为kmeans使用的数据格式n行，一样一样本B = reshape(I(:, :, 2), M*N, 1);C = reshape(I(:, :, 3), M*N, 1);K = 3;dat = [A B C ]; % 三个分量组成样本的特征，每个样本有3个属性值，共width*height个样本c3 = kmeans(double(dat), K); % 使用聚类算法分为K类r3 = reshape(c3, M, N); % 反向转化为图片形式figure, imshow(label2rgb(r3)) % 显示分割结果title(&#x27;调用matlab库函数&#x27;);labels=reshape(c3, M, N);segmented_images = cell( 1 ,K);rgb_label = repmat(labels,[1 1 3]);for k= 1:Kcolor= I; color(rgb_label~= k)= 0;segmented_images &#123;k&#125; = color;end%显示分割结果figure,imshow(segmented_images &#123;1&#125;),title(&#x27;分割结果1&#x27;);figure,imshow(segmented_images &#123;2&#125;),title(&#x27;分割结果2&#x27;);figure,imshow(segmented_images &#123;3&#125;);title(&#x27;分割结果3&#x27;); 4、实验结果 结束","categories":[{"name":"模式识别","slug":"模式识别","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/"}],"tags":[{"name":"聚类算法","slug":"聚类算法","permalink":"http://example.com/tags/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/"}]}]