[{"title":"Hello World","date":"2021-05-17T04:32:31.843Z","path":"2021/05/17/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"C++06_STL初识","date":"2020-08-08T08:32:40.000Z","path":"2020/08/08/C-06-STL初识/","text":"STL初识 STL的基本概念 STL(Standard Template Library)标准模板库 STL几乎所有的代码都使用了模板类和模板函数 STL的六大部件六大部件：容器、算法、迭代器、仿函数、适配器、空间配置器 容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据 算法：各种常用算法，如sort、find、copy、for_each等 迭代器：容器和算法之间的胶合剂 仿函数：行为类似数，可最作为算法的某种策略 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西 空间适配器：负责空间的配置与管理 STL的容器、算法、迭代器容器容器：置物之容所 STL容器：将运用最广泛的一些数据结构（数组、链表、树、栈、队列、集合、映射表）实现出来 容器可分为序列式容器和关联式容器两种： 序列式容器：强调值的排序，序列式容器中的每个元素都有固定的位置 关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系 算法算法（Algorithm）：问题之解法 算法又分为质变算法和非质变算法两种： 质变算法：是指运算过程中会更改区间内的元素的内容（拷贝、替换、删除） 非质变算法：是指运算过程中不会改变区间内元素的内容（查找、计数、遍历、寻找极值） 迭代器迭代器：容器和算法之间的粘合剂 提供一种方法，使之既可以依序寻访某个容器所含的各个元素，又无需暴露给容器的内部表示方式，迭代器非常类似指针。 种类 功能 支持运算 输入迭代器 只读 ++、==、！= 输出迭代器 只写 ++ 前向迭代器 读写，只能向前推进 ++、==、！= 双向迭代器 读写，能向前和向后推进 ++、– 随机访问迭代器 读写，可以以跳跃的方式访问任意数据 ++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;= 常用的容器迭代器有双向迭代器、随机访问迭代器 STL容器算法迭代器初识vector存放内置数据类型容器：vector 算法：for_each 迭代器：vector: :iterator 具体案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;#include&lt;vector&gt;//标准容器头文件#include&lt;algorithm&gt;//标准算法头文件void myprint(int val)&#123; cout &lt;&lt; val &lt;&lt; endl;&#125;void test01()&#123; vector&lt;int&gt; v;//创建一个容量，数组 //尾插法添加一些数据 v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); v.push_back(50); //把这些数据显示出来 //第一种遍历方式： cout &lt;&lt; &quot;第一种遍历方式：-------------&quot; &lt;&lt; endl; vector&lt;int&gt;::iterator itBegin = v.begin();//起始迭代器，指向容器的第一个元素 vector&lt;int&gt;::iterator itEnd = v.end();//末尾迭代器，指向容器的最后一个元素的下一个位置 while (itBegin!=itEnd) &#123; cout &lt;&lt; *itBegin &lt;&lt; endl; itBegin++; &#125; //第二种遍历方式 cout &lt;&lt; &quot;第二种遍历方式：-------------&quot; &lt;&lt; endl; for (vector&lt;int&gt;::iterator itBegin2 = v.begin(); itBegin2 != v.end(); itBegin2++) &#123; cout &lt;&lt; *itBegin2 &lt;&lt; endl; &#125; //第三种遍历方式 cout &lt;&lt; &quot;第三种遍历方式：-------------&quot; &lt;&lt; endl; for_each(v.begin(),v.end(),myprint);//for_each(初始迭代器，末尾迭代器，实现函数名)&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; vector存放自定义数据类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;using namespace std;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;string&gt;class person&#123;public: class person(int age,string name) &#123; m_age = age; m_name = name; &#125; int m_age; string m_name;&#125;;void myprint(person &amp;p)&#123; cout &lt;&lt; p.m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; p.m_age &lt;&lt; &quot;\\t&quot; &lt;&lt; endl;&#125;//存放自定义数据void test01()&#123; vector&lt;person&gt; v; //添加数据 person p1(18, &quot;张三&quot;); person p2(19, &quot;李四&quot;); person p3(20, &quot;王五&quot;); v.push_back(p1); v.push_back(p2); v.push_back(p3); cout &lt;&lt; &quot;姓名\\t&quot; &lt;&lt; &quot;年龄\\t&quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myprint);&#125;//存放自定义数据指针void test02()&#123; vector&lt;person*&gt; v; //添加数据 person p1(18, &quot;张三&quot;); person p2(19, &quot;李四&quot;); person p3(20, &quot;王五&quot;); v.push_back(&amp;p1); v.push_back(&amp;p2); v.push_back(&amp;p3); cout &lt;&lt; &quot;姓名2\\t&quot; &lt;&lt; &quot;年龄2\\t&quot; &lt;&lt; endl; //for_each(v.begin(), v.end(), myprint); for (vector&lt;person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; (*it)-&gt;m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; (*it)-&gt;m_age &lt;&lt; &quot;\\t&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; vector容器嵌套容器123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;#include&lt;vector&gt;void test01()&#123; vector&lt;vector&lt;int&gt;&gt; v; vector&lt;int&gt; v1; vector&lt;int&gt; v2; vector&lt;int&gt; v3; vector&lt;int&gt; v4; vector&lt;int&gt; v5; for (int i = 0; i &lt; 5; i++) &#123; v1.push_back(i + 1); v2.push_back(i + 2); v3.push_back(i + 3); v4.push_back(i + 4); v5.push_back(i + 5); &#125; v.push_back(v1); v.push_back(v2); v.push_back(v3); v.push_back(v4); v.push_back(v5); for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; for (vector&lt;int&gt;::iterator vit = it-&gt;begin(); vit != it-&gt;end(); vit++) &#123; cout &lt;&lt; *vit &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125;&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]}]